/**
 * Generated by orval v7.17.0 ðŸº
 * Do not edit manually.
 * Smart YouTube Bookmarks API
 * 
API for managing YouTube video collections with custom fields, real-time processing, and video enrichment.

## Features

- **Lists** â€“ Create and manage video collections
- **Videos** â€“ Add, import (CSV), export, and manage videos
- **Custom Fields** â€“ Define rating, select, text, and boolean fields
- **Field Schemas** â€“ Create reusable field templates
- **Channels** â€“ Auto-created from video metadata
- **Tags** â€“ Organize videos with custom tags
- **Enrichment** â€“ Transcripts and AI-powered metadata
- **Real-Time Progress** â€“ WebSocket-based import tracking

## Authentication

Currently uses a hardcoded user_id for development. Production deployment requires proper authentication.
    
 * OpenAPI spec version: 0.1.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  CheckDuplicateFieldApiListsListIdCustomFieldsCheckDuplicatePost200,
  CheckDuplicateFieldApiListsListIdCustomFieldsCheckDuplicatePostParams,
  CustomFieldCreate,
  CustomFieldResponse,
  CustomFieldUpdate,
  DuplicateCheckRequest,
  HTTPValidationError
} from '.././model';

import { customInstance } from '../../../lib/axios-instance';




/**
 * List all custom fields for a bookmark list.

Returns all field definitions ordered by creation date (newest first).
Fields are list-scoped and can be reused across multiple schemas.

Args:
    list_id: UUID of the bookmark list
    db: Database session

Returns:
    List[CustomFieldResponse]: All custom fields in the list

Raises:
    HTTPException 404: List not found

Example Response:
    [
        {
            "id": "123e4567-e89b-12d3-a456-426614174000",
            "list_id": "987fcdeb-51a2-43d1-9012-345678901234",
            "name": "Presentation Quality",
            "field_type": "select",
            "config": {
                "options": ["bad", "all over the place", "confusing", "great"]
            },
            "created_at": "2025-11-06T10:30:00Z",
            "updated_at": "2025-11-06T10:30:00Z"
        },
        {
            "id": "234e5678-e89b-12d3-a456-426614174001",
            "list_id": "987fcdeb-51a2-43d1-9012-345678901234",
            "name": "Overall Rating",
            "field_type": "rating",
            "config": {"max_rating": 5},
            "created_at": "2025-11-06T10:25:00Z",
            "updated_at": "2025-11-06T10:25:00Z"
        }
    ]
 * @summary List Custom Fields
 */
export const listCustomFieldsApiListsListIdCustomFieldsGet = (
    listId: string,
 signal?: AbortSignal
) => {
      
      
      return customInstance<CustomFieldResponse[]>(
      {url: `/api/lists/${listId}/custom-fields`, method: 'GET', signal
    },
      );
    }
  



export const getListCustomFieldsApiListsListIdCustomFieldsGetQueryKey = (listId?: string,) => {
    return [
    `/api/lists/${listId}/custom-fields`
    ] as const;
    }

    
export const getListCustomFieldsApiListsListIdCustomFieldsGetQueryOptions = <TData = Awaited<ReturnType<typeof listCustomFieldsApiListsListIdCustomFieldsGet>>, TError = HTTPValidationError>(listId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listCustomFieldsApiListsListIdCustomFieldsGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListCustomFieldsApiListsListIdCustomFieldsGetQueryKey(listId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listCustomFieldsApiListsListIdCustomFieldsGet>>> = ({ signal }) => listCustomFieldsApiListsListIdCustomFieldsGet(listId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(listId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listCustomFieldsApiListsListIdCustomFieldsGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ListCustomFieldsApiListsListIdCustomFieldsGetQueryResult = NonNullable<Awaited<ReturnType<typeof listCustomFieldsApiListsListIdCustomFieldsGet>>>
export type ListCustomFieldsApiListsListIdCustomFieldsGetQueryError = HTTPValidationError


export function useListCustomFieldsApiListsListIdCustomFieldsGet<TData = Awaited<ReturnType<typeof listCustomFieldsApiListsListIdCustomFieldsGet>>, TError = HTTPValidationError>(
 listId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof listCustomFieldsApiListsListIdCustomFieldsGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listCustomFieldsApiListsListIdCustomFieldsGet>>,
          TError,
          Awaited<ReturnType<typeof listCustomFieldsApiListsListIdCustomFieldsGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useListCustomFieldsApiListsListIdCustomFieldsGet<TData = Awaited<ReturnType<typeof listCustomFieldsApiListsListIdCustomFieldsGet>>, TError = HTTPValidationError>(
 listId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listCustomFieldsApiListsListIdCustomFieldsGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listCustomFieldsApiListsListIdCustomFieldsGet>>,
          TError,
          Awaited<ReturnType<typeof listCustomFieldsApiListsListIdCustomFieldsGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useListCustomFieldsApiListsListIdCustomFieldsGet<TData = Awaited<ReturnType<typeof listCustomFieldsApiListsListIdCustomFieldsGet>>, TError = HTTPValidationError>(
 listId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listCustomFieldsApiListsListIdCustomFieldsGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary List Custom Fields
 */

export function useListCustomFieldsApiListsListIdCustomFieldsGet<TData = Awaited<ReturnType<typeof listCustomFieldsApiListsListIdCustomFieldsGet>>, TError = HTTPValidationError>(
 listId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listCustomFieldsApiListsListIdCustomFieldsGet>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getListCustomFieldsApiListsListIdCustomFieldsGetQueryOptions(listId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Create a new custom field in a bookmark list.

Validates that:
- List exists (404 if not found)
- Field name is unique within list (case-insensitive, 409 if duplicate)
- Config matches field_type requirements (delegated to Pydantic schema)

Args:
    list_id: UUID of the bookmark list
    field_data: CustomFieldCreate schema with name, field_type, config
    db: Database session

Returns:
    CustomFieldResponse: Created field with generated ID and timestamps

Raises:
    HTTPException 404: List not found
    HTTPException 409: Field name already exists (case-insensitive)
    HTTPException 422: Pydantic validation errors (auto-generated)

Example Request:
    POST /api/lists/{list_id}/custom-fields
    {
        "name": "Presentation Quality",
        "field_type": "select",
        "config": {
            "options": ["bad", "all over the place", "confusing", "great"]
        }
    }
 * @summary Create Custom Field
 */
export const createCustomFieldApiListsListIdCustomFieldsPost = (
    listId: string,
    customFieldCreate: CustomFieldCreate,
 signal?: AbortSignal
) => {
      
      
      return customInstance<CustomFieldResponse>(
      {url: `/api/lists/${listId}/custom-fields`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: customFieldCreate, signal
    },
      );
    }
  


export const getCreateCustomFieldApiListsListIdCustomFieldsPostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createCustomFieldApiListsListIdCustomFieldsPost>>, TError,{listId: string;data: CustomFieldCreate}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof createCustomFieldApiListsListIdCustomFieldsPost>>, TError,{listId: string;data: CustomFieldCreate}, TContext> => {

const mutationKey = ['createCustomFieldApiListsListIdCustomFieldsPost'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createCustomFieldApiListsListIdCustomFieldsPost>>, {listId: string;data: CustomFieldCreate}> = (props) => {
          const {listId,data} = props ?? {};

          return  createCustomFieldApiListsListIdCustomFieldsPost(listId,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateCustomFieldApiListsListIdCustomFieldsPostMutationResult = NonNullable<Awaited<ReturnType<typeof createCustomFieldApiListsListIdCustomFieldsPost>>>
    export type CreateCustomFieldApiListsListIdCustomFieldsPostMutationBody = CustomFieldCreate
    export type CreateCustomFieldApiListsListIdCustomFieldsPostMutationError = HTTPValidationError

    /**
 * @summary Create Custom Field
 */
export const useCreateCustomFieldApiListsListIdCustomFieldsPost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createCustomFieldApiListsListIdCustomFieldsPost>>, TError,{listId: string;data: CustomFieldCreate}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createCustomFieldApiListsListIdCustomFieldsPost>>,
        TError,
        {listId: string;data: CustomFieldCreate},
        TContext
      > => {

      const mutationOptions = getCreateCustomFieldApiListsListIdCustomFieldsPostMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Update an existing custom field.

Supports partial updates (all fields optional). When updating name,
performs case-insensitive duplicate check. Config validation is
delegated to Pydantic schema (Task #64).

Args:
    list_id: UUID of the bookmark list
    field_id: UUID of the field to update
    field_update: CustomFieldUpdate schema (all fields optional)
    db: Database session

Returns:
    CustomFieldResponse: Updated field with new timestamps

Raises:
    HTTPException 404: List or field not found
    HTTPException 409: New field name already exists (case-insensitive)
    HTTPException 422: Pydantic validation errors (auto-generated)

Example Request (partial update):
    PUT /api/lists/{list_id}/custom-fields/{field_id}
    {"name": "Updated Field Name"}

Example Request (full update):
    PUT /api/lists/{list_id}/custom-fields/{field_id}
    {
        "name": "Overall Rating",
        "field_type": "rating",
        "config": {"max_rating": 10}
    }

Note: Changing field_type on fields with existing values may cause
data inconsistencies. Frontend should warn users before allowing this.
 * @summary Update Custom Field
 */
export const updateCustomFieldApiListsListIdCustomFieldsFieldIdPut = (
    listId: string,
    fieldId: string,
    customFieldUpdate: CustomFieldUpdate,
 ) => {
      
      
      return customInstance<CustomFieldResponse>(
      {url: `/api/lists/${listId}/custom-fields/${fieldId}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: customFieldUpdate
    },
      );
    }
  


export const getUpdateCustomFieldApiListsListIdCustomFieldsFieldIdPutMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateCustomFieldApiListsListIdCustomFieldsFieldIdPut>>, TError,{listId: string;fieldId: string;data: CustomFieldUpdate}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof updateCustomFieldApiListsListIdCustomFieldsFieldIdPut>>, TError,{listId: string;fieldId: string;data: CustomFieldUpdate}, TContext> => {

const mutationKey = ['updateCustomFieldApiListsListIdCustomFieldsFieldIdPut'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateCustomFieldApiListsListIdCustomFieldsFieldIdPut>>, {listId: string;fieldId: string;data: CustomFieldUpdate}> = (props) => {
          const {listId,fieldId,data} = props ?? {};

          return  updateCustomFieldApiListsListIdCustomFieldsFieldIdPut(listId,fieldId,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateCustomFieldApiListsListIdCustomFieldsFieldIdPutMutationResult = NonNullable<Awaited<ReturnType<typeof updateCustomFieldApiListsListIdCustomFieldsFieldIdPut>>>
    export type UpdateCustomFieldApiListsListIdCustomFieldsFieldIdPutMutationBody = CustomFieldUpdate
    export type UpdateCustomFieldApiListsListIdCustomFieldsFieldIdPutMutationError = HTTPValidationError

    /**
 * @summary Update Custom Field
 */
export const useUpdateCustomFieldApiListsListIdCustomFieldsFieldIdPut = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateCustomFieldApiListsListIdCustomFieldsFieldIdPut>>, TError,{listId: string;fieldId: string;data: CustomFieldUpdate}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateCustomFieldApiListsListIdCustomFieldsFieldIdPut>>,
        TError,
        {listId: string;fieldId: string;data: CustomFieldUpdate},
        TContext
      > => {

      const mutationOptions = getUpdateCustomFieldApiListsListIdCustomFieldsFieldIdPutMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Delete a custom field from a bookmark list.

Validates that field is not used in any schema before deletion.
If field is used in schemas, returns 409 Conflict with usage count.

Cascade behavior:
- Deletes all VideoFieldValue records (CASCADE via ORM)
- Does NOT delete SchemaField associations (must be removed first)

Args:
    list_id: UUID of the bookmark list
    field_id: UUID of the field to delete
    db: Database session

Returns:
    None (204 No Content on success)

Raises:
    HTTPException 404: List or field not found
    HTTPException 409: Field is used in one or more schemas

Example Success:
    DELETE /api/lists/{list_id}/custom-fields/{field_id}
    Response: 204 No Content

Example Failure (field in use):
    DELETE /api/lists/{list_id}/custom-fields/{field_id}
    Response: 409 Conflict
    {
        "detail": "Cannot delete field 'Overall Rating' - used in 2 schema(s). Remove field from schemas first."
    }
 * @summary Delete Custom Field
 */
export const deleteCustomFieldApiListsListIdCustomFieldsFieldIdDelete = (
    listId: string,
    fieldId: string,
 ) => {
      
      
      return customInstance<void>(
      {url: `/api/lists/${listId}/custom-fields/${fieldId}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteCustomFieldApiListsListIdCustomFieldsFieldIdDeleteMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteCustomFieldApiListsListIdCustomFieldsFieldIdDelete>>, TError,{listId: string;fieldId: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof deleteCustomFieldApiListsListIdCustomFieldsFieldIdDelete>>, TError,{listId: string;fieldId: string}, TContext> => {

const mutationKey = ['deleteCustomFieldApiListsListIdCustomFieldsFieldIdDelete'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteCustomFieldApiListsListIdCustomFieldsFieldIdDelete>>, {listId: string;fieldId: string}> = (props) => {
          const {listId,fieldId} = props ?? {};

          return  deleteCustomFieldApiListsListIdCustomFieldsFieldIdDelete(listId,fieldId,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteCustomFieldApiListsListIdCustomFieldsFieldIdDeleteMutationResult = NonNullable<Awaited<ReturnType<typeof deleteCustomFieldApiListsListIdCustomFieldsFieldIdDelete>>>
    
    export type DeleteCustomFieldApiListsListIdCustomFieldsFieldIdDeleteMutationError = HTTPValidationError

    /**
 * @summary Delete Custom Field
 */
export const useDeleteCustomFieldApiListsListIdCustomFieldsFieldIdDelete = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteCustomFieldApiListsListIdCustomFieldsFieldIdDelete>>, TError,{listId: string;fieldId: string}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteCustomFieldApiListsListIdCustomFieldsFieldIdDelete>>,
        TError,
        {listId: string;fieldId: string},
        TContext
      > => {

      const mutationOptions = getDeleteCustomFieldApiListsListIdCustomFieldsFieldIdDeleteMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Check if a custom field with the given name already exists.

Supports two modes:
- **basic** (default): Case-insensitive exact match only (fast, <50ms)
- **smart**: Exact + Levenshtein + Semantic similarity (slower, <500ms)

Smart mode detects:
- Typos: "Presentaton" â†’ "Presentation Quality" (Levenshtein distance < 3)
- Semantic: "Video Rating" â†’ "Overall Score" (AI embeddings cosine similarity > 0.75)

Args:
    list_id: UUID of the list to check within
    request: Request body containing the field name to check
    mode: Detection mode ("basic" or "smart")
    db: Database session

Returns:
    - Basic mode: DuplicateCheckResponse (backward compatible)
    - Smart mode: SmartDuplicateCheckResponse with ranked suggestions

Example Smart Response:
    {
        "exists": true,
        "suggestions": [
            {
                "field": {...},
                "score": 0.95,
                "similarity_type": "levenshtein",
                "explanation": "Very similar name (1 character difference)"
            }
        ],
        "mode": "smart"
    }
 * @summary Check Duplicate Field
 */
export const checkDuplicateFieldApiListsListIdCustomFieldsCheckDuplicatePost = (
    listId: string,
    duplicateCheckRequest: DuplicateCheckRequest,
    params?: CheckDuplicateFieldApiListsListIdCustomFieldsCheckDuplicatePostParams,
 signal?: AbortSignal
) => {
      
      
      return customInstance<CheckDuplicateFieldApiListsListIdCustomFieldsCheckDuplicatePost200>(
      {url: `/api/lists/${listId}/custom-fields/check-duplicate`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: duplicateCheckRequest,
        params, signal
    },
      );
    }
  


export const getCheckDuplicateFieldApiListsListIdCustomFieldsCheckDuplicatePostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof checkDuplicateFieldApiListsListIdCustomFieldsCheckDuplicatePost>>, TError,{listId: string;data: DuplicateCheckRequest;params?: CheckDuplicateFieldApiListsListIdCustomFieldsCheckDuplicatePostParams}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof checkDuplicateFieldApiListsListIdCustomFieldsCheckDuplicatePost>>, TError,{listId: string;data: DuplicateCheckRequest;params?: CheckDuplicateFieldApiListsListIdCustomFieldsCheckDuplicatePostParams}, TContext> => {

const mutationKey = ['checkDuplicateFieldApiListsListIdCustomFieldsCheckDuplicatePost'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof checkDuplicateFieldApiListsListIdCustomFieldsCheckDuplicatePost>>, {listId: string;data: DuplicateCheckRequest;params?: CheckDuplicateFieldApiListsListIdCustomFieldsCheckDuplicatePostParams}> = (props) => {
          const {listId,data,params} = props ?? {};

          return  checkDuplicateFieldApiListsListIdCustomFieldsCheckDuplicatePost(listId,data,params,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CheckDuplicateFieldApiListsListIdCustomFieldsCheckDuplicatePostMutationResult = NonNullable<Awaited<ReturnType<typeof checkDuplicateFieldApiListsListIdCustomFieldsCheckDuplicatePost>>>
    export type CheckDuplicateFieldApiListsListIdCustomFieldsCheckDuplicatePostMutationBody = DuplicateCheckRequest
    export type CheckDuplicateFieldApiListsListIdCustomFieldsCheckDuplicatePostMutationError = HTTPValidationError

    /**
 * @summary Check Duplicate Field
 */
export const useCheckDuplicateFieldApiListsListIdCustomFieldsCheckDuplicatePost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof checkDuplicateFieldApiListsListIdCustomFieldsCheckDuplicatePost>>, TError,{listId: string;data: DuplicateCheckRequest;params?: CheckDuplicateFieldApiListsListIdCustomFieldsCheckDuplicatePostParams}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof checkDuplicateFieldApiListsListIdCustomFieldsCheckDuplicatePost>>,
        TError,
        {listId: string;data: DuplicateCheckRequest;params?: CheckDuplicateFieldApiListsListIdCustomFieldsCheckDuplicatePostParams},
        TContext
      > => {

      const mutationOptions = getCheckDuplicateFieldApiListsListIdCustomFieldsCheckDuplicatePostMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    