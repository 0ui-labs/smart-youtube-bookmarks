/**
 * Generated by orval v7.17.0 ðŸº
 * Do not edit manually.
 * Smart YouTube Bookmarks API
 * 
API for managing YouTube video collections with custom fields, real-time processing, and video enrichment.

## Features

- **Lists** â€“ Create and manage video collections
- **Videos** â€“ Add, import (CSV), export, and manage videos
- **Custom Fields** â€“ Define rating, select, text, and boolean fields
- **Field Schemas** â€“ Create reusable field templates
- **Channels** â€“ Auto-created from video metadata
- **Tags** â€“ Organize videos with custom tags
- **Enrichment** â€“ Transcripts and AI-powered metadata
- **Real-Time Progress** â€“ WebSocket-based import tracking

## Authentication

Currently uses a hardcoded user_id for development. Production deployment requires proper authentication.
    
 * OpenAPI spec version: 0.1.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  AssignTagsRequest,
  BatchUpdateFieldValuesRequest,
  BatchUpdateFieldValuesResponse,
  BodyBulkUploadVideosApiListsListIdVideosBulkPost,
  BulkAssignTagsRequest,
  BulkAssignTagsToVideosApiVideosBulkTagsPost200,
  BulkUploadResponse,
  GetVideosInListApiListsListIdVideosGetParams,
  HTTPValidationError,
  ListAllVideosApiVideosGetParams,
  SetCategoryRequest,
  SetCategoryResponse,
  SetVideoCategoryApiVideosVideoIdCategoryPutParams,
  TagResponse,
  UpdateWatchProgressRequest,
  UpdateWatchProgressResponse,
  VideoAdd,
  VideoFilterRequest,
  VideoResponse
} from '.././model';

import { customInstance } from '../../../lib/axios-instance';




/**
 * Add a video to a bookmark list with ARQ background processing (Option B).

- Validates list exists (404 if not found)
- Extracts YouTube video ID from URL
- Creates video with pending status
- Queues ARQ background task for metadata fetching
- Checks for duplicates (409 if already in list)

This approach is production-ready for large batches and prevents request timeouts.

Args:
    list_id: UUID of the bookmark list
    video_data: Video data with YouTube URL
    db: Database session

Returns:
    VideoResponse: Created video with pending status

Raises:
    HTTPException 404: List not found
    HTTPException 409: Video already in list
    HTTPException 422: Invalid YouTube URL
 * @summary Add Video To List
 */
export const addVideoToListApiListsListIdVideosPost = (
    listId: string,
    videoAdd: VideoAdd,
 signal?: AbortSignal
) => {
      
      
      return customInstance<VideoResponse>(
      {url: `/api/lists/${listId}/videos`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: videoAdd, signal
    },
      );
    }
  


export const getAddVideoToListApiListsListIdVideosPostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof addVideoToListApiListsListIdVideosPost>>, TError,{listId: string;data: VideoAdd}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof addVideoToListApiListsListIdVideosPost>>, TError,{listId: string;data: VideoAdd}, TContext> => {

const mutationKey = ['addVideoToListApiListsListIdVideosPost'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addVideoToListApiListsListIdVideosPost>>, {listId: string;data: VideoAdd}> = (props) => {
          const {listId,data} = props ?? {};

          return  addVideoToListApiListsListIdVideosPost(listId,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AddVideoToListApiListsListIdVideosPostMutationResult = NonNullable<Awaited<ReturnType<typeof addVideoToListApiListsListIdVideosPost>>>
    export type AddVideoToListApiListsListIdVideosPostMutationBody = VideoAdd
    export type AddVideoToListApiListsListIdVideosPostMutationError = HTTPValidationError

    /**
 * @summary Add Video To List
 */
export const useAddVideoToListApiListsListIdVideosPost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof addVideoToListApiListsListIdVideosPost>>, TError,{listId: string;data: VideoAdd}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof addVideoToListApiListsListIdVideosPost>>,
        TError,
        {listId: string;data: VideoAdd},
        TContext
      > => {

      const mutationOptions = getAddVideoToListApiListsListIdVideosPostMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Get all videos in a bookmark list with optional tag filtering and sorting.

Args:
    list_id: UUID of the bookmark list
    tags: Optional list of tag names for OR filtering (case-insensitive)
    sort_by: Sort column (standard column or 'field:<field_id>')
    sort_order: Sort direction ('asc' or 'desc')
    db: Database session

Returns:
    List[VideoResponse]: List of videos in the bookmark list

Raises:
    HTTPException 404: List not found or custom field not found
    HTTPException 400: Invalid sort_by parameter

Examples:
    - /api/lists/{id}/videos - All videos in list (default: created_at DESC)
    - /api/lists/{id}/videos?tags=Python&tags=Tutorial - Videos with Python OR Tutorial tags
    - /api/lists/{id}/videos?sort_by=title&sort_order=asc - Videos sorted by title A-Z
    - /api/lists/{id}/videos?sort_by=field:uuid-rating-field&sort_order=desc - Videos sorted by rating field
 * @summary Get Videos In List
 */
export const getVideosInListApiListsListIdVideosGet = (
    listId: string,
    params?: GetVideosInListApiListsListIdVideosGetParams,
 signal?: AbortSignal
) => {
      
      
      return customInstance<VideoResponse[]>(
      {url: `/api/lists/${listId}/videos`, method: 'GET',
        params, signal
    },
      );
    }
  



export const getGetVideosInListApiListsListIdVideosGetQueryKey = (listId?: string,
    params?: GetVideosInListApiListsListIdVideosGetParams,) => {
    return [
    `/api/lists/${listId}/videos`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getGetVideosInListApiListsListIdVideosGetQueryOptions = <TData = Awaited<ReturnType<typeof getVideosInListApiListsListIdVideosGet>>, TError = HTTPValidationError>(listId: string,
    params?: GetVideosInListApiListsListIdVideosGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getVideosInListApiListsListIdVideosGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetVideosInListApiListsListIdVideosGetQueryKey(listId,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getVideosInListApiListsListIdVideosGet>>> = ({ signal }) => getVideosInListApiListsListIdVideosGet(listId,params, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(listId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getVideosInListApiListsListIdVideosGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetVideosInListApiListsListIdVideosGetQueryResult = NonNullable<Awaited<ReturnType<typeof getVideosInListApiListsListIdVideosGet>>>
export type GetVideosInListApiListsListIdVideosGetQueryError = HTTPValidationError


export function useGetVideosInListApiListsListIdVideosGet<TData = Awaited<ReturnType<typeof getVideosInListApiListsListIdVideosGet>>, TError = HTTPValidationError>(
 listId: string,
    params: undefined |  GetVideosInListApiListsListIdVideosGetParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getVideosInListApiListsListIdVideosGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getVideosInListApiListsListIdVideosGet>>,
          TError,
          Awaited<ReturnType<typeof getVideosInListApiListsListIdVideosGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetVideosInListApiListsListIdVideosGet<TData = Awaited<ReturnType<typeof getVideosInListApiListsListIdVideosGet>>, TError = HTTPValidationError>(
 listId: string,
    params?: GetVideosInListApiListsListIdVideosGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getVideosInListApiListsListIdVideosGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getVideosInListApiListsListIdVideosGet>>,
          TError,
          Awaited<ReturnType<typeof getVideosInListApiListsListIdVideosGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetVideosInListApiListsListIdVideosGet<TData = Awaited<ReturnType<typeof getVideosInListApiListsListIdVideosGet>>, TError = HTTPValidationError>(
 listId: string,
    params?: GetVideosInListApiListsListIdVideosGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getVideosInListApiListsListIdVideosGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get Videos In List
 */

export function useGetVideosInListApiListsListIdVideosGet<TData = Awaited<ReturnType<typeof getVideosInListApiListsListIdVideosGet>>, TError = HTTPValidationError>(
 listId: string,
    params?: GetVideosInListApiListsListIdVideosGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getVideosInListApiListsListIdVideosGet>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetVideosInListApiListsListIdVideosGetQueryOptions(listId,params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Filter videos in a bookmark list by tags and/or custom field values.

Filtering Logic:
- Tags: OR logic (video matches ANY selected tag)
- Field filters: AND logic (video matches ALL field filters)
- Tags + Field filters: Combined with AND

Examples:
    POST /api/lists/{id}/videos/filter
    Body: {"tags": ["Python"], "field_filters": [{"field_id": "...", "operator": "gte", "value": 4}]}
    -> Videos with tag "Python" AND rating >= 4

    Body: {"field_filters": [{"field_id": "...", "operator": "contains", "value": "tutorial"}]}
    -> Videos where field contains "tutorial"

    Body: {"tags": ["Python", "JavaScript"]}
    -> Videos with Python OR JavaScript tags

Args:
    list_id: UUID of the bookmark list
    filter_request: Filter criteria (tags and/or field filters)
    db: Database session

Returns:
    List[VideoResponse]: Filtered videos

Raises:
    HTTPException 404: List not found
 * @summary Filter Videos In List
 */
export const filterVideosInListApiListsListIdVideosFilterPost = (
    listId: string,
    videoFilterRequest: VideoFilterRequest,
 signal?: AbortSignal
) => {
      
      
      return customInstance<VideoResponse[]>(
      {url: `/api/lists/${listId}/videos/filter`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: videoFilterRequest, signal
    },
      );
    }
  


export const getFilterVideosInListApiListsListIdVideosFilterPostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof filterVideosInListApiListsListIdVideosFilterPost>>, TError,{listId: string;data: VideoFilterRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof filterVideosInListApiListsListIdVideosFilterPost>>, TError,{listId: string;data: VideoFilterRequest}, TContext> => {

const mutationKey = ['filterVideosInListApiListsListIdVideosFilterPost'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof filterVideosInListApiListsListIdVideosFilterPost>>, {listId: string;data: VideoFilterRequest}> = (props) => {
          const {listId,data} = props ?? {};

          return  filterVideosInListApiListsListIdVideosFilterPost(listId,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type FilterVideosInListApiListsListIdVideosFilterPostMutationResult = NonNullable<Awaited<ReturnType<typeof filterVideosInListApiListsListIdVideosFilterPost>>>
    export type FilterVideosInListApiListsListIdVideosFilterPostMutationBody = VideoFilterRequest
    export type FilterVideosInListApiListsListIdVideosFilterPostMutationError = HTTPValidationError

    /**
 * @summary Filter Videos In List
 */
export const useFilterVideosInListApiListsListIdVideosFilterPost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof filterVideosInListApiListsListIdVideosFilterPost>>, TError,{listId: string;data: VideoFilterRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof filterVideosInListApiListsListIdVideosFilterPost>>,
        TError,
        {listId: string;data: VideoFilterRequest},
        TContext
      > => {

      const mutationOptions = getFilterVideosInListApiListsListIdVideosFilterPostMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Get single video with complete field information (detail view).

Returns:
- field_values: ALL available fields with their current values (null if unfilled)
- available_fields: Field metadata for all editable fields (name, type, config)

Note: field_values includes ALL applicable fields (from video's tags),
with value=None for fields that haven't been filled yet. This allows
the frontend to render all editable fields in the detail modal.

Use Case: Modal/Detail view where user can see and edit all fields.
 * @summary Get Video By Id
 */
export const getVideoByIdApiVideosVideoIdGet = (
    videoId: string,
 signal?: AbortSignal
) => {
      
      
      return customInstance<VideoResponse>(
      {url: `/api/videos/${videoId}`, method: 'GET', signal
    },
      );
    }
  



export const getGetVideoByIdApiVideosVideoIdGetQueryKey = (videoId?: string,) => {
    return [
    `/api/videos/${videoId}`
    ] as const;
    }

    
export const getGetVideoByIdApiVideosVideoIdGetQueryOptions = <TData = Awaited<ReturnType<typeof getVideoByIdApiVideosVideoIdGet>>, TError = HTTPValidationError>(videoId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getVideoByIdApiVideosVideoIdGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetVideoByIdApiVideosVideoIdGetQueryKey(videoId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getVideoByIdApiVideosVideoIdGet>>> = ({ signal }) => getVideoByIdApiVideosVideoIdGet(videoId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(videoId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getVideoByIdApiVideosVideoIdGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetVideoByIdApiVideosVideoIdGetQueryResult = NonNullable<Awaited<ReturnType<typeof getVideoByIdApiVideosVideoIdGet>>>
export type GetVideoByIdApiVideosVideoIdGetQueryError = HTTPValidationError


export function useGetVideoByIdApiVideosVideoIdGet<TData = Awaited<ReturnType<typeof getVideoByIdApiVideosVideoIdGet>>, TError = HTTPValidationError>(
 videoId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getVideoByIdApiVideosVideoIdGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getVideoByIdApiVideosVideoIdGet>>,
          TError,
          Awaited<ReturnType<typeof getVideoByIdApiVideosVideoIdGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetVideoByIdApiVideosVideoIdGet<TData = Awaited<ReturnType<typeof getVideoByIdApiVideosVideoIdGet>>, TError = HTTPValidationError>(
 videoId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getVideoByIdApiVideosVideoIdGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getVideoByIdApiVideosVideoIdGet>>,
          TError,
          Awaited<ReturnType<typeof getVideoByIdApiVideosVideoIdGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetVideoByIdApiVideosVideoIdGet<TData = Awaited<ReturnType<typeof getVideoByIdApiVideosVideoIdGet>>, TError = HTTPValidationError>(
 videoId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getVideoByIdApiVideosVideoIdGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get Video By Id
 */

export function useGetVideoByIdApiVideosVideoIdGet<TData = Awaited<ReturnType<typeof getVideoByIdApiVideosVideoIdGet>>, TError = HTTPValidationError>(
 videoId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getVideoByIdApiVideosVideoIdGet>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetVideoByIdApiVideosVideoIdGetQueryOptions(videoId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Delete a video from a bookmark list.

Also auto-deletes the channel if this was the last video in that channel
(YouTube Channels feature - Step 6.7).

Args:
    video_id: UUID of the video to delete
    db: Database session

Raises:
    HTTPException 404: Video not found
 * @summary Delete Video
 */
export const deleteVideoApiVideosVideoIdDelete = (
    videoId: string,
 ) => {
      
      
      return customInstance<void>(
      {url: `/api/videos/${videoId}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteVideoApiVideosVideoIdDeleteMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteVideoApiVideosVideoIdDelete>>, TError,{videoId: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof deleteVideoApiVideosVideoIdDelete>>, TError,{videoId: string}, TContext> => {

const mutationKey = ['deleteVideoApiVideosVideoIdDelete'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteVideoApiVideosVideoIdDelete>>, {videoId: string}> = (props) => {
          const {videoId} = props ?? {};

          return  deleteVideoApiVideosVideoIdDelete(videoId,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteVideoApiVideosVideoIdDeleteMutationResult = NonNullable<Awaited<ReturnType<typeof deleteVideoApiVideosVideoIdDelete>>>
    
    export type DeleteVideoApiVideosVideoIdDeleteMutationError = HTTPValidationError

    /**
 * @summary Delete Video
 */
export const useDeleteVideoApiVideosVideoIdDelete = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteVideoApiVideosVideoIdDelete>>, TError,{videoId: string}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteVideoApiVideosVideoIdDelete>>,
        TError,
        {videoId: string},
        TContext
      > => {

      const mutationOptions = getDeleteVideoApiVideosVideoIdDeleteMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Update watch progress for a video (video player integration).

Saves the current playback position so users can resume watching later.
Called periodically (debounced) by the video player and on pause.

Args:
    video_id: UUID of the video
    request: UpdateWatchProgressRequest with position in seconds
    db: Database session

Returns:
    UpdateWatchProgressResponse with video_id, watch_position, updated_at

Raises:
    HTTPException 404: Video not found
 * @summary Update Watch Progress
 */
export const updateWatchProgressApiVideosVideoIdProgressPatch = (
    videoId: string,
    updateWatchProgressRequest: UpdateWatchProgressRequest,
 ) => {
      
      
      return customInstance<UpdateWatchProgressResponse>(
      {url: `/api/videos/${videoId}/progress`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: updateWatchProgressRequest
    },
      );
    }
  


export const getUpdateWatchProgressApiVideosVideoIdProgressPatchMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateWatchProgressApiVideosVideoIdProgressPatch>>, TError,{videoId: string;data: UpdateWatchProgressRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof updateWatchProgressApiVideosVideoIdProgressPatch>>, TError,{videoId: string;data: UpdateWatchProgressRequest}, TContext> => {

const mutationKey = ['updateWatchProgressApiVideosVideoIdProgressPatch'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateWatchProgressApiVideosVideoIdProgressPatch>>, {videoId: string;data: UpdateWatchProgressRequest}> = (props) => {
          const {videoId,data} = props ?? {};

          return  updateWatchProgressApiVideosVideoIdProgressPatch(videoId,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateWatchProgressApiVideosVideoIdProgressPatchMutationResult = NonNullable<Awaited<ReturnType<typeof updateWatchProgressApiVideosVideoIdProgressPatch>>>
    export type UpdateWatchProgressApiVideosVideoIdProgressPatchMutationBody = UpdateWatchProgressRequest
    export type UpdateWatchProgressApiVideosVideoIdProgressPatchMutationError = HTTPValidationError

    /**
 * @summary Update Watch Progress
 */
export const useUpdateWatchProgressApiVideosVideoIdProgressPatch = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateWatchProgressApiVideosVideoIdProgressPatch>>, TError,{videoId: string;data: UpdateWatchProgressRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateWatchProgressApiVideosVideoIdProgressPatch>>,
        TError,
        {videoId: string;data: UpdateWatchProgressRequest},
        TContext
      > => {

      const mutationOptions = getUpdateWatchProgressApiVideosVideoIdProgressPatchMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * List all videos with optional tag filtering.

Query params:
- tags: OR filter (any matching tag) - can be specified multiple times
- tags_all: AND filter (all tags required) - can be specified multiple times

Examples:
- /api/videos - All videos
- /api/videos?tags=Python&tags=Tutorial - Videos with Python OR Tutorial tags
- /api/videos?tags_all=Python&tags_all=Advanced - Videos with BOTH Python AND Advanced tags
 * @summary List All Videos
 */
export const listAllVideosApiVideosGet = (
    params?: ListAllVideosApiVideosGetParams,
 signal?: AbortSignal
) => {
      
      
      return customInstance<VideoResponse[]>(
      {url: `/api/videos`, method: 'GET',
        params, signal
    },
      );
    }
  



export const getListAllVideosApiVideosGetQueryKey = (params?: ListAllVideosApiVideosGetParams,) => {
    return [
    `/api/videos`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getListAllVideosApiVideosGetQueryOptions = <TData = Awaited<ReturnType<typeof listAllVideosApiVideosGet>>, TError = HTTPValidationError>(params?: ListAllVideosApiVideosGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listAllVideosApiVideosGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListAllVideosApiVideosGetQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listAllVideosApiVideosGet>>> = ({ signal }) => listAllVideosApiVideosGet(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listAllVideosApiVideosGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ListAllVideosApiVideosGetQueryResult = NonNullable<Awaited<ReturnType<typeof listAllVideosApiVideosGet>>>
export type ListAllVideosApiVideosGetQueryError = HTTPValidationError


export function useListAllVideosApiVideosGet<TData = Awaited<ReturnType<typeof listAllVideosApiVideosGet>>, TError = HTTPValidationError>(
 params: undefined |  ListAllVideosApiVideosGetParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof listAllVideosApiVideosGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listAllVideosApiVideosGet>>,
          TError,
          Awaited<ReturnType<typeof listAllVideosApiVideosGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useListAllVideosApiVideosGet<TData = Awaited<ReturnType<typeof listAllVideosApiVideosGet>>, TError = HTTPValidationError>(
 params?: ListAllVideosApiVideosGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listAllVideosApiVideosGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listAllVideosApiVideosGet>>,
          TError,
          Awaited<ReturnType<typeof listAllVideosApiVideosGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useListAllVideosApiVideosGet<TData = Awaited<ReturnType<typeof listAllVideosApiVideosGet>>, TError = HTTPValidationError>(
 params?: ListAllVideosApiVideosGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listAllVideosApiVideosGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary List All Videos
 */

export function useListAllVideosApiVideosGet<TData = Awaited<ReturnType<typeof listAllVideosApiVideosGet>>, TError = HTTPValidationError>(
 params?: ListAllVideosApiVideosGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listAllVideosApiVideosGet>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getListAllVideosApiVideosGetQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Bulk upload videos from CSV file with optional custom field values.

**CSV Format (Extended):**
```
url,field_Overall_Rating,field_Presentation
https://youtube.com/watch?v=dQw4w9WgXcQ,5,great
https://youtu.be/jNQXAC9IVRw,3,good
```

**Field Columns:**
- Format: `field_<field_name>` (case-insensitive matching)
- Values validated per field type (rating: int, select: option, text: max_length, boolean: true/false)
- Invalid field values logged as warnings, video still created
- Field updates applied via batch update endpoint (Task #72)

**Validation:**
- URL column required (422 if missing)
- Field columns optional (videos created even if field validation fails)
- Row-level error handling: Continue processing on field errors

Args:
    list_id: UUID of the bookmark list
    file: CSV file with YouTube URLs and optional field columns
    db: Database session

Returns:
    BulkUploadResponse: Statistics with created_count, failed_count, failures list

Raises:
    HTTPException 404: List not found
    HTTPException 422: Invalid CSV header or file format
 * @summary Bulk Upload Videos
 */
export const bulkUploadVideosApiListsListIdVideosBulkPost = (
    listId: string,
    bodyBulkUploadVideosApiListsListIdVideosBulkPost: BodyBulkUploadVideosApiListsListIdVideosBulkPost,
 signal?: AbortSignal
) => {
      
      const formData = new FormData();
formData.append(`file`, bodyBulkUploadVideosApiListsListIdVideosBulkPost.file)

      return customInstance<BulkUploadResponse>(
      {url: `/api/lists/${listId}/videos/bulk`, method: 'POST',
      headers: {'Content-Type': 'multipart/form-data', },
       data: formData, signal
    },
      );
    }
  


export const getBulkUploadVideosApiListsListIdVideosBulkPostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof bulkUploadVideosApiListsListIdVideosBulkPost>>, TError,{listId: string;data: BodyBulkUploadVideosApiListsListIdVideosBulkPost}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof bulkUploadVideosApiListsListIdVideosBulkPost>>, TError,{listId: string;data: BodyBulkUploadVideosApiListsListIdVideosBulkPost}, TContext> => {

const mutationKey = ['bulkUploadVideosApiListsListIdVideosBulkPost'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof bulkUploadVideosApiListsListIdVideosBulkPost>>, {listId: string;data: BodyBulkUploadVideosApiListsListIdVideosBulkPost}> = (props) => {
          const {listId,data} = props ?? {};

          return  bulkUploadVideosApiListsListIdVideosBulkPost(listId,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type BulkUploadVideosApiListsListIdVideosBulkPostMutationResult = NonNullable<Awaited<ReturnType<typeof bulkUploadVideosApiListsListIdVideosBulkPost>>>
    export type BulkUploadVideosApiListsListIdVideosBulkPostMutationBody = BodyBulkUploadVideosApiListsListIdVideosBulkPost
    export type BulkUploadVideosApiListsListIdVideosBulkPostMutationError = HTTPValidationError

    /**
 * @summary Bulk Upload Videos
 */
export const useBulkUploadVideosApiListsListIdVideosBulkPost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof bulkUploadVideosApiListsListIdVideosBulkPost>>, TError,{listId: string;data: BodyBulkUploadVideosApiListsListIdVideosBulkPost}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof bulkUploadVideosApiListsListIdVideosBulkPost>>,
        TError,
        {listId: string;data: BodyBulkUploadVideosApiListsListIdVideosBulkPost},
        TContext
      > => {

      const mutationOptions = getBulkUploadVideosApiListsListIdVideosBulkPostMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Export all videos in a list to CSV format with custom field values.

**CSV Format (Extended):**
```
# Custom Fields: Overall Rating (rating, 1-5), Presentation (select: bad|good|great)
youtube_id,status,created_at,field_Overall_Rating,field_Presentation
dQw4w9WgXcQ,completed,2025-11-08T10:00:00,5,great
jNQXAC9IVRw,pending,2025-11-08T11:00:00,,
```

**Field Columns:**
- Named `field_<field_name>` (e.g., "field_Overall_Rating")
- Sorted alphabetically after standard columns
- Empty values exported as empty string (not "NULL")
- Metadata comment line includes field types for reference

**Performance:**
- Optimized for lists up to 1000 videos Ã— 20 fields
- Single query with eager loading (prevents N+1)
- Target: < 2s for 100 videos Ã— 10 fields

Args:
    list_id: UUID of the bookmark list
    db: Database session

Returns:
    StreamingResponse: CSV file download

Raises:
    HTTPException 404: List not found
 * @summary Export Videos Csv
 */
export const exportVideosCsvApiListsListIdExportCsvGet = (
    listId: string,
 signal?: AbortSignal
) => {
      
      
      return customInstance<unknown>(
      {url: `/api/lists/${listId}/export/csv`, method: 'GET', signal
    },
      );
    }
  



export const getExportVideosCsvApiListsListIdExportCsvGetQueryKey = (listId?: string,) => {
    return [
    `/api/lists/${listId}/export/csv`
    ] as const;
    }

    
export const getExportVideosCsvApiListsListIdExportCsvGetQueryOptions = <TData = Awaited<ReturnType<typeof exportVideosCsvApiListsListIdExportCsvGet>>, TError = HTTPValidationError>(listId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof exportVideosCsvApiListsListIdExportCsvGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getExportVideosCsvApiListsListIdExportCsvGetQueryKey(listId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof exportVideosCsvApiListsListIdExportCsvGet>>> = ({ signal }) => exportVideosCsvApiListsListIdExportCsvGet(listId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(listId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof exportVideosCsvApiListsListIdExportCsvGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ExportVideosCsvApiListsListIdExportCsvGetQueryResult = NonNullable<Awaited<ReturnType<typeof exportVideosCsvApiListsListIdExportCsvGet>>>
export type ExportVideosCsvApiListsListIdExportCsvGetQueryError = HTTPValidationError


export function useExportVideosCsvApiListsListIdExportCsvGet<TData = Awaited<ReturnType<typeof exportVideosCsvApiListsListIdExportCsvGet>>, TError = HTTPValidationError>(
 listId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof exportVideosCsvApiListsListIdExportCsvGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof exportVideosCsvApiListsListIdExportCsvGet>>,
          TError,
          Awaited<ReturnType<typeof exportVideosCsvApiListsListIdExportCsvGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useExportVideosCsvApiListsListIdExportCsvGet<TData = Awaited<ReturnType<typeof exportVideosCsvApiListsListIdExportCsvGet>>, TError = HTTPValidationError>(
 listId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof exportVideosCsvApiListsListIdExportCsvGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof exportVideosCsvApiListsListIdExportCsvGet>>,
          TError,
          Awaited<ReturnType<typeof exportVideosCsvApiListsListIdExportCsvGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useExportVideosCsvApiListsListIdExportCsvGet<TData = Awaited<ReturnType<typeof exportVideosCsvApiListsListIdExportCsvGet>>, TError = HTTPValidationError>(
 listId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof exportVideosCsvApiListsListIdExportCsvGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Export Videos Csv
 */

export function useExportVideosCsvApiListsListIdExportCsvGet<TData = Awaited<ReturnType<typeof exportVideosCsvApiListsListIdExportCsvGet>>, TError = HTTPValidationError>(
 listId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof exportVideosCsvApiListsListIdExportCsvGet>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getExportVideosCsvApiListsListIdExportCsvGetQueryOptions(listId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Bulk assign tags to multiple videos (cartesian product).

Creates all possible video-tag associations for the given video_ids and tag_ids.
Duplicates are ignored (idempotent).

Args:
    request: BulkAssignTagsRequest with video_ids and tag_ids
    db: Database session

Returns:
    dict: {"assigned": int, "total_requested": int}
    - assigned: number of new associations created
    - total_requested: total number of assignments requested

Raises:
    HTTPException 400: Batch exceeds 10,000 assignments
    HTTPException 404: Some videos or tags not found
 * @summary Bulk Assign Tags To Videos
 */
export const bulkAssignTagsToVideosApiVideosBulkTagsPost = (
    bulkAssignTagsRequest: BulkAssignTagsRequest,
 signal?: AbortSignal
) => {
      
      
      return customInstance<BulkAssignTagsToVideosApiVideosBulkTagsPost200>(
      {url: `/api/videos/bulk/tags`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: bulkAssignTagsRequest, signal
    },
      );
    }
  


export const getBulkAssignTagsToVideosApiVideosBulkTagsPostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof bulkAssignTagsToVideosApiVideosBulkTagsPost>>, TError,{data: BulkAssignTagsRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof bulkAssignTagsToVideosApiVideosBulkTagsPost>>, TError,{data: BulkAssignTagsRequest}, TContext> => {

const mutationKey = ['bulkAssignTagsToVideosApiVideosBulkTagsPost'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof bulkAssignTagsToVideosApiVideosBulkTagsPost>>, {data: BulkAssignTagsRequest}> = (props) => {
          const {data} = props ?? {};

          return  bulkAssignTagsToVideosApiVideosBulkTagsPost(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type BulkAssignTagsToVideosApiVideosBulkTagsPostMutationResult = NonNullable<Awaited<ReturnType<typeof bulkAssignTagsToVideosApiVideosBulkTagsPost>>>
    export type BulkAssignTagsToVideosApiVideosBulkTagsPostMutationBody = BulkAssignTagsRequest
    export type BulkAssignTagsToVideosApiVideosBulkTagsPostMutationError = HTTPValidationError

    /**
 * @summary Bulk Assign Tags To Videos
 */
export const useBulkAssignTagsToVideosApiVideosBulkTagsPost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof bulkAssignTagsToVideosApiVideosBulkTagsPost>>, TError,{data: BulkAssignTagsRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof bulkAssignTagsToVideosApiVideosBulkTagsPost>>,
        TError,
        {data: BulkAssignTagsRequest},
        TContext
      > => {

      const mutationOptions = getBulkAssignTagsToVideosApiVideosBulkTagsPostMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Assign tags to a video (many-to-many). Returns the updated list of tags.
 * @summary Assign Tags To Video
 */
export const assignTagsToVideoApiVideosVideoIdTagsPost = (
    videoId: string,
    assignTagsRequest: AssignTagsRequest,
 signal?: AbortSignal
) => {
      
      
      return customInstance<TagResponse[]>(
      {url: `/api/videos/${videoId}/tags`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: assignTagsRequest, signal
    },
      );
    }
  


export const getAssignTagsToVideoApiVideosVideoIdTagsPostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof assignTagsToVideoApiVideosVideoIdTagsPost>>, TError,{videoId: string;data: AssignTagsRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof assignTagsToVideoApiVideosVideoIdTagsPost>>, TError,{videoId: string;data: AssignTagsRequest}, TContext> => {

const mutationKey = ['assignTagsToVideoApiVideosVideoIdTagsPost'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof assignTagsToVideoApiVideosVideoIdTagsPost>>, {videoId: string;data: AssignTagsRequest}> = (props) => {
          const {videoId,data} = props ?? {};

          return  assignTagsToVideoApiVideosVideoIdTagsPost(videoId,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AssignTagsToVideoApiVideosVideoIdTagsPostMutationResult = NonNullable<Awaited<ReturnType<typeof assignTagsToVideoApiVideosVideoIdTagsPost>>>
    export type AssignTagsToVideoApiVideosVideoIdTagsPostMutationBody = AssignTagsRequest
    export type AssignTagsToVideoApiVideosVideoIdTagsPostMutationError = HTTPValidationError

    /**
 * @summary Assign Tags To Video
 */
export const useAssignTagsToVideoApiVideosVideoIdTagsPost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof assignTagsToVideoApiVideosVideoIdTagsPost>>, TError,{videoId: string;data: AssignTagsRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof assignTagsToVideoApiVideosVideoIdTagsPost>>,
        TError,
        {videoId: string;data: AssignTagsRequest},
        TContext
      > => {

      const mutationOptions = getAssignTagsToVideoApiVideosVideoIdTagsPostMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Get all tags for a video.
 * @summary Get Video Tags
 */
export const getVideoTagsApiVideosVideoIdTagsGet = (
    videoId: string,
 signal?: AbortSignal
) => {
      
      
      return customInstance<TagResponse[]>(
      {url: `/api/videos/${videoId}/tags`, method: 'GET', signal
    },
      );
    }
  



export const getGetVideoTagsApiVideosVideoIdTagsGetQueryKey = (videoId?: string,) => {
    return [
    `/api/videos/${videoId}/tags`
    ] as const;
    }

    
export const getGetVideoTagsApiVideosVideoIdTagsGetQueryOptions = <TData = Awaited<ReturnType<typeof getVideoTagsApiVideosVideoIdTagsGet>>, TError = HTTPValidationError>(videoId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getVideoTagsApiVideosVideoIdTagsGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetVideoTagsApiVideosVideoIdTagsGetQueryKey(videoId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getVideoTagsApiVideosVideoIdTagsGet>>> = ({ signal }) => getVideoTagsApiVideosVideoIdTagsGet(videoId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(videoId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getVideoTagsApiVideosVideoIdTagsGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetVideoTagsApiVideosVideoIdTagsGetQueryResult = NonNullable<Awaited<ReturnType<typeof getVideoTagsApiVideosVideoIdTagsGet>>>
export type GetVideoTagsApiVideosVideoIdTagsGetQueryError = HTTPValidationError


export function useGetVideoTagsApiVideosVideoIdTagsGet<TData = Awaited<ReturnType<typeof getVideoTagsApiVideosVideoIdTagsGet>>, TError = HTTPValidationError>(
 videoId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getVideoTagsApiVideosVideoIdTagsGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getVideoTagsApiVideosVideoIdTagsGet>>,
          TError,
          Awaited<ReturnType<typeof getVideoTagsApiVideosVideoIdTagsGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetVideoTagsApiVideosVideoIdTagsGet<TData = Awaited<ReturnType<typeof getVideoTagsApiVideosVideoIdTagsGet>>, TError = HTTPValidationError>(
 videoId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getVideoTagsApiVideosVideoIdTagsGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getVideoTagsApiVideosVideoIdTagsGet>>,
          TError,
          Awaited<ReturnType<typeof getVideoTagsApiVideosVideoIdTagsGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetVideoTagsApiVideosVideoIdTagsGet<TData = Awaited<ReturnType<typeof getVideoTagsApiVideosVideoIdTagsGet>>, TError = HTTPValidationError>(
 videoId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getVideoTagsApiVideosVideoIdTagsGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get Video Tags
 */

export function useGetVideoTagsApiVideosVideoIdTagsGet<TData = Awaited<ReturnType<typeof getVideoTagsApiVideosVideoIdTagsGet>>, TError = HTTPValidationError>(
 videoId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getVideoTagsApiVideosVideoIdTagsGet>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetVideoTagsApiVideosVideoIdTagsGetQueryOptions(videoId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Remove a tag from a video.
 * @summary Remove Tag From Video
 */
export const removeTagFromVideoApiVideosVideoIdTagsTagIdDelete = (
    videoId: string,
    tagId: string,
 ) => {
      
      
      return customInstance<void>(
      {url: `/api/videos/${videoId}/tags/${tagId}`, method: 'DELETE'
    },
      );
    }
  


export const getRemoveTagFromVideoApiVideosVideoIdTagsTagIdDeleteMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof removeTagFromVideoApiVideosVideoIdTagsTagIdDelete>>, TError,{videoId: string;tagId: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof removeTagFromVideoApiVideosVideoIdTagsTagIdDelete>>, TError,{videoId: string;tagId: string}, TContext> => {

const mutationKey = ['removeTagFromVideoApiVideosVideoIdTagsTagIdDelete'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof removeTagFromVideoApiVideosVideoIdTagsTagIdDelete>>, {videoId: string;tagId: string}> = (props) => {
          const {videoId,tagId} = props ?? {};

          return  removeTagFromVideoApiVideosVideoIdTagsTagIdDelete(videoId,tagId,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type RemoveTagFromVideoApiVideosVideoIdTagsTagIdDeleteMutationResult = NonNullable<Awaited<ReturnType<typeof removeTagFromVideoApiVideosVideoIdTagsTagIdDelete>>>
    
    export type RemoveTagFromVideoApiVideosVideoIdTagsTagIdDeleteMutationError = HTTPValidationError

    /**
 * @summary Remove Tag From Video
 */
export const useRemoveTagFromVideoApiVideosVideoIdTagsTagIdDelete = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof removeTagFromVideoApiVideosVideoIdTagsTagIdDelete>>, TError,{videoId: string;tagId: string}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof removeTagFromVideoApiVideosVideoIdTagsTagIdDelete>>,
        TError,
        {videoId: string;tagId: string},
        TContext
      > => {

      const mutationOptions = getRemoveTagFromVideoApiVideosVideoIdTagsTagIdDeleteMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Set video's category (replaces existing).

This endpoint handles category changes with backup/restore functionality:
- If video has existing category with field values, creates backup before removal
- If new category has existing backup and restore_backup=true, restores values

Args:
    video_id: UUID of video to update
    request: SetCategoryRequest with new category_id (null to remove)
    restore_backup: If true and backup exists for new category, restore values
    db: Database session

Returns:
    SetCategoryResponse with backup_created, backup_available, restored_count

Raises:
    HTTPException 404: Video not found
    HTTPException 400: Tag is not a category (is_video_type=false)
 * @summary Set Video Category
 */
export const setVideoCategoryApiVideosVideoIdCategoryPut = (
    videoId: string,
    setCategoryRequest: SetCategoryRequest,
    params?: SetVideoCategoryApiVideosVideoIdCategoryPutParams,
 ) => {
      
      
      return customInstance<SetCategoryResponse>(
      {url: `/api/videos/${videoId}/category`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: setCategoryRequest,
        params
    },
      );
    }
  


export const getSetVideoCategoryApiVideosVideoIdCategoryPutMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof setVideoCategoryApiVideosVideoIdCategoryPut>>, TError,{videoId: string;data: SetCategoryRequest;params?: SetVideoCategoryApiVideosVideoIdCategoryPutParams}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof setVideoCategoryApiVideosVideoIdCategoryPut>>, TError,{videoId: string;data: SetCategoryRequest;params?: SetVideoCategoryApiVideosVideoIdCategoryPutParams}, TContext> => {

const mutationKey = ['setVideoCategoryApiVideosVideoIdCategoryPut'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof setVideoCategoryApiVideosVideoIdCategoryPut>>, {videoId: string;data: SetCategoryRequest;params?: SetVideoCategoryApiVideosVideoIdCategoryPutParams}> = (props) => {
          const {videoId,data,params} = props ?? {};

          return  setVideoCategoryApiVideosVideoIdCategoryPut(videoId,data,params,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SetVideoCategoryApiVideosVideoIdCategoryPutMutationResult = NonNullable<Awaited<ReturnType<typeof setVideoCategoryApiVideosVideoIdCategoryPut>>>
    export type SetVideoCategoryApiVideosVideoIdCategoryPutMutationBody = SetCategoryRequest
    export type SetVideoCategoryApiVideosVideoIdCategoryPutMutationError = HTTPValidationError

    /**
 * @summary Set Video Category
 */
export const useSetVideoCategoryApiVideosVideoIdCategoryPut = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof setVideoCategoryApiVideosVideoIdCategoryPut>>, TError,{videoId: string;data: SetCategoryRequest;params?: SetVideoCategoryApiVideosVideoIdCategoryPutParams}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof setVideoCategoryApiVideosVideoIdCategoryPut>>,
        TError,
        {videoId: string;data: SetCategoryRequest;params?: SetVideoCategoryApiVideosVideoIdCategoryPutParams},
        TContext
      > => {

      const mutationOptions = getSetVideoCategoryApiVideosVideoIdCategoryPutMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Batch update custom field values for a video.

Updates multiple field values atomically in a single transaction.
Creates new VideoFieldValue records if they don't exist (upsert behavior).

**Validation:**
- Video must exist (404 if not found)
- All field_ids must be valid CustomFields (400 if invalid)
- Values validated per field type (422 if validation fails)
  - Rating: numeric, 0 to max_rating
  - Select: string, in options list
  - Text: string, max_length if configured
  - Boolean: true/false

**Transaction Semantics:**
- All-or-nothing: If any validation fails, no changes are persisted
- Upsert: Creates if doesn't exist, updates if exists

**Performance:**
- Optimized for batches up to 50 fields
- Single database round-trip for validation queries
- Uses PostgreSQL UPSERT (ON CONFLICT DO UPDATE) for efficiency

Args:
    video_id: UUID of video to update field values for
    request: Batch update request with list of field_id/value pairs
    db: Database session

Returns:
    Response with updated_count and list of updated field values

Raises:
    HTTPException:
        - 404: Video not found
        - 400: Invalid field_id (field doesn't exist)
        - 422: Validation error (value incompatible with field type)

Example:
    PUT /api/videos/{video_id}/fields
    {
        "field_values": [
            {"field_id": "uuid1", "value": 5},
            {"field_id": "uuid2", "value": "great"}
        ]
    }

    Response (200):
    {
        "updated_count": 2,
        "field_values": [
            {
                "field_id": "uuid1",
                "value": 5,
                "schema_name": null,
                "show_on_card": true,
                "display_order": 0,
                "field": {
                    "id": "uuid1",
                    "name": "Overall Rating",
                    "field_type": "rating",
                    "config": {"max_rating": 5}
                }
            },
            ...
        ]
    }
 * @summary Batch Update Video Field Values
 */
export const batchUpdateVideoFieldValuesApiVideosVideoIdFieldsPut = (
    videoId: string,
    batchUpdateFieldValuesRequest: BatchUpdateFieldValuesRequest,
 ) => {
      
      
      return customInstance<BatchUpdateFieldValuesResponse>(
      {url: `/api/videos/${videoId}/fields`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: batchUpdateFieldValuesRequest
    },
      );
    }
  


export const getBatchUpdateVideoFieldValuesApiVideosVideoIdFieldsPutMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof batchUpdateVideoFieldValuesApiVideosVideoIdFieldsPut>>, TError,{videoId: string;data: BatchUpdateFieldValuesRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof batchUpdateVideoFieldValuesApiVideosVideoIdFieldsPut>>, TError,{videoId: string;data: BatchUpdateFieldValuesRequest}, TContext> => {

const mutationKey = ['batchUpdateVideoFieldValuesApiVideosVideoIdFieldsPut'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof batchUpdateVideoFieldValuesApiVideosVideoIdFieldsPut>>, {videoId: string;data: BatchUpdateFieldValuesRequest}> = (props) => {
          const {videoId,data} = props ?? {};

          return  batchUpdateVideoFieldValuesApiVideosVideoIdFieldsPut(videoId,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type BatchUpdateVideoFieldValuesApiVideosVideoIdFieldsPutMutationResult = NonNullable<Awaited<ReturnType<typeof batchUpdateVideoFieldValuesApiVideosVideoIdFieldsPut>>>
    export type BatchUpdateVideoFieldValuesApiVideosVideoIdFieldsPutMutationBody = BatchUpdateFieldValuesRequest
    export type BatchUpdateVideoFieldValuesApiVideosVideoIdFieldsPutMutationError = HTTPValidationError

    /**
 * @summary Batch Update Video Field Values
 */
export const useBatchUpdateVideoFieldValuesApiVideosVideoIdFieldsPut = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof batchUpdateVideoFieldValuesApiVideosVideoIdFieldsPut>>, TError,{videoId: string;data: BatchUpdateFieldValuesRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof batchUpdateVideoFieldValuesApiVideosVideoIdFieldsPut>>,
        TError,
        {videoId: string;data: BatchUpdateFieldValuesRequest},
        TContext
      > => {

      const mutationOptions = getBatchUpdateVideoFieldValuesApiVideosVideoIdFieldsPutMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    