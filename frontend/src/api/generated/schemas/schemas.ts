/**
 * Generated by orval v7.17.0 ðŸº
 * Do not edit manually.
 * Smart YouTube Bookmarks API
 * 
API for managing YouTube video collections with custom fields, real-time processing, and video enrichment.

## Features

- **Lists** â€“ Create and manage video collections
- **Videos** â€“ Add, import (CSV), export, and manage videos
- **Custom Fields** â€“ Define rating, select, text, and boolean fields
- **Field Schemas** â€“ Create reusable field templates
- **Channels** â€“ Auto-created from video metadata
- **Tags** â€“ Organize videos with custom tags
- **Enrichment** â€“ Transcripts and AI-powered metadata
- **Real-Time Progress** â€“ WebSocket-based import tracking

## Authentication

Currently uses a hardcoded user_id for development. Production deployment requires proper authentication.
    
 * OpenAPI spec version: 0.1.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  FieldSchemaCreate,
  FieldSchemaResponse,
  FieldSchemaUpdate,
  HTTPValidationError
} from '.././model';

import { customInstance } from '../../../lib/axios-instance';




/**
 * List all field schemas for a list.

Returns all schemas with their associated fields (eager loaded).
Results ordered by schema name.

Args:
    list_id: UUID of the parent list
    db: Database session (injected)

Returns:
    List of FieldSchemaResponse objects with nested schema_fields

Example Response:
    [
        {
            "id": "schema-uuid",
            "list_id": "list-uuid",
            "name": "Video Quality",
            "description": "Standard quality metrics",
            "schema_fields": [
                {
                    "field_id": "field-uuid",
                    "schema_id": "schema-uuid",
                    "display_order": 0,
                    "show_on_card": true,
                    "field": {
                        "id": "field-uuid",
                        "name": "Presentation",
                        "field_type": "select",
                        ...
                    }
                }
            ],
            "created_at": "...",
            "updated_at": "..."
        }
    ]
 * @summary List Schemas
 */
export const listSchemasApiListsListIdSchemasGet = (
    listId: string,
 signal?: AbortSignal
) => {
      
      
      return customInstance<FieldSchemaResponse[]>(
      {url: `/api/lists/${listId}/schemas`, method: 'GET', signal
    },
      );
    }
  



export const getListSchemasApiListsListIdSchemasGetQueryKey = (listId?: string,) => {
    return [
    `/api/lists/${listId}/schemas`
    ] as const;
    }

    
export const getListSchemasApiListsListIdSchemasGetQueryOptions = <TData = Awaited<ReturnType<typeof listSchemasApiListsListIdSchemasGet>>, TError = HTTPValidationError>(listId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listSchemasApiListsListIdSchemasGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListSchemasApiListsListIdSchemasGetQueryKey(listId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listSchemasApiListsListIdSchemasGet>>> = ({ signal }) => listSchemasApiListsListIdSchemasGet(listId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(listId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listSchemasApiListsListIdSchemasGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ListSchemasApiListsListIdSchemasGetQueryResult = NonNullable<Awaited<ReturnType<typeof listSchemasApiListsListIdSchemasGet>>>
export type ListSchemasApiListsListIdSchemasGetQueryError = HTTPValidationError


export function useListSchemasApiListsListIdSchemasGet<TData = Awaited<ReturnType<typeof listSchemasApiListsListIdSchemasGet>>, TError = HTTPValidationError>(
 listId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof listSchemasApiListsListIdSchemasGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listSchemasApiListsListIdSchemasGet>>,
          TError,
          Awaited<ReturnType<typeof listSchemasApiListsListIdSchemasGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useListSchemasApiListsListIdSchemasGet<TData = Awaited<ReturnType<typeof listSchemasApiListsListIdSchemasGet>>, TError = HTTPValidationError>(
 listId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listSchemasApiListsListIdSchemasGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listSchemasApiListsListIdSchemasGet>>,
          TError,
          Awaited<ReturnType<typeof listSchemasApiListsListIdSchemasGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useListSchemasApiListsListIdSchemasGet<TData = Awaited<ReturnType<typeof listSchemasApiListsListIdSchemasGet>>, TError = HTTPValidationError>(
 listId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listSchemasApiListsListIdSchemasGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary List Schemas
 */

export function useListSchemasApiListsListIdSchemasGet<TData = Awaited<ReturnType<typeof listSchemasApiListsListIdSchemasGet>>, TError = HTTPValidationError>(
 listId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listSchemasApiListsListIdSchemasGet>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getListSchemasApiListsListIdSchemasGetQueryOptions(listId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Create a new field schema.

Optionally creates SchemaField associations if fields array provided.
All field_ids must exist in the same list as the schema.

Args:
    list_id: UUID of the parent list
    schema_data: Schema creation data (name, description, optional fields)
    db: Database session (injected)

Returns:
    Created FieldSchemaResponse with nested schema_fields

Raises:
    HTTPException 404: List not found
    HTTPException 400: One or more field_ids invalid or belong to different list

Example Request:
    {
        "name": "Video Quality",
        "description": "Standard metrics",
        "fields": [
            {
                "field_id": "uuid-1",
                "display_order": 0,
                "show_on_card": true
            }
        ]
    }
 * @summary Create Schema
 */
export const createSchemaApiListsListIdSchemasPost = (
    listId: string,
    fieldSchemaCreate: FieldSchemaCreate,
 signal?: AbortSignal
) => {
      
      
      return customInstance<FieldSchemaResponse>(
      {url: `/api/lists/${listId}/schemas`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: fieldSchemaCreate, signal
    },
      );
    }
  


export const getCreateSchemaApiListsListIdSchemasPostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createSchemaApiListsListIdSchemasPost>>, TError,{listId: string;data: FieldSchemaCreate}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof createSchemaApiListsListIdSchemasPost>>, TError,{listId: string;data: FieldSchemaCreate}, TContext> => {

const mutationKey = ['createSchemaApiListsListIdSchemasPost'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createSchemaApiListsListIdSchemasPost>>, {listId: string;data: FieldSchemaCreate}> = (props) => {
          const {listId,data} = props ?? {};

          return  createSchemaApiListsListIdSchemasPost(listId,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateSchemaApiListsListIdSchemasPostMutationResult = NonNullable<Awaited<ReturnType<typeof createSchemaApiListsListIdSchemasPost>>>
    export type CreateSchemaApiListsListIdSchemasPostMutationBody = FieldSchemaCreate
    export type CreateSchemaApiListsListIdSchemasPostMutationError = HTTPValidationError

    /**
 * @summary Create Schema
 */
export const useCreateSchemaApiListsListIdSchemasPost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createSchemaApiListsListIdSchemasPost>>, TError,{listId: string;data: FieldSchemaCreate}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createSchemaApiListsListIdSchemasPost>>,
        TError,
        {listId: string;data: FieldSchemaCreate},
        TContext
      > => {

      const mutationOptions = getCreateSchemaApiListsListIdSchemasPostMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Get a single field schema by ID.

Returns schema with associated fields (eager loaded).

Args:
    list_id: UUID of the parent list
    schema_id: UUID of the schema to retrieve
    db: Database session (injected)

Returns:
    FieldSchemaResponse with nested schema_fields

Raises:
    HTTPException 404: Schema not found or belongs to different list
 * @summary Get Schema
 */
export const getSchemaApiListsListIdSchemasSchemaIdGet = (
    listId: string,
    schemaId: string,
 signal?: AbortSignal
) => {
      
      
      return customInstance<FieldSchemaResponse>(
      {url: `/api/lists/${listId}/schemas/${schemaId}`, method: 'GET', signal
    },
      );
    }
  



export const getGetSchemaApiListsListIdSchemasSchemaIdGetQueryKey = (listId?: string,
    schemaId?: string,) => {
    return [
    `/api/lists/${listId}/schemas/${schemaId}`
    ] as const;
    }

    
export const getGetSchemaApiListsListIdSchemasSchemaIdGetQueryOptions = <TData = Awaited<ReturnType<typeof getSchemaApiListsListIdSchemasSchemaIdGet>>, TError = HTTPValidationError>(listId: string,
    schemaId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSchemaApiListsListIdSchemasSchemaIdGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetSchemaApiListsListIdSchemasSchemaIdGetQueryKey(listId,schemaId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getSchemaApiListsListIdSchemasSchemaIdGet>>> = ({ signal }) => getSchemaApiListsListIdSchemasSchemaIdGet(listId,schemaId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(listId && schemaId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getSchemaApiListsListIdSchemasSchemaIdGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetSchemaApiListsListIdSchemasSchemaIdGetQueryResult = NonNullable<Awaited<ReturnType<typeof getSchemaApiListsListIdSchemasSchemaIdGet>>>
export type GetSchemaApiListsListIdSchemasSchemaIdGetQueryError = HTTPValidationError


export function useGetSchemaApiListsListIdSchemasSchemaIdGet<TData = Awaited<ReturnType<typeof getSchemaApiListsListIdSchemasSchemaIdGet>>, TError = HTTPValidationError>(
 listId: string,
    schemaId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSchemaApiListsListIdSchemasSchemaIdGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSchemaApiListsListIdSchemasSchemaIdGet>>,
          TError,
          Awaited<ReturnType<typeof getSchemaApiListsListIdSchemasSchemaIdGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetSchemaApiListsListIdSchemasSchemaIdGet<TData = Awaited<ReturnType<typeof getSchemaApiListsListIdSchemasSchemaIdGet>>, TError = HTTPValidationError>(
 listId: string,
    schemaId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSchemaApiListsListIdSchemasSchemaIdGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSchemaApiListsListIdSchemasSchemaIdGet>>,
          TError,
          Awaited<ReturnType<typeof getSchemaApiListsListIdSchemasSchemaIdGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetSchemaApiListsListIdSchemasSchemaIdGet<TData = Awaited<ReturnType<typeof getSchemaApiListsListIdSchemasSchemaIdGet>>, TError = HTTPValidationError>(
 listId: string,
    schemaId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSchemaApiListsListIdSchemasSchemaIdGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get Schema
 */

export function useGetSchemaApiListsListIdSchemasSchemaIdGet<TData = Awaited<ReturnType<typeof getSchemaApiListsListIdSchemasSchemaIdGet>>, TError = HTTPValidationError>(
 listId: string,
    schemaId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSchemaApiListsListIdSchemasSchemaIdGet>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetSchemaApiListsListIdSchemasSchemaIdGetQueryOptions(listId,schemaId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update field schema metadata (name and/or description).

Only updates schema metadata. Field management (adding/removing fields
from schema) is handled by separate endpoints in Task #69.

Args:
    list_id: UUID of the parent list
    schema_id: UUID of the schema to update
    schema_update: Update data (name, description - both optional)
    db: Database session (injected)

Returns:
    Updated FieldSchemaResponse

Raises:
    HTTPException 404: Schema not found or belongs to different list

Example Request:
    {"name": "Updated Video Quality"}
 * @summary Update Schema
 */
export const updateSchemaApiListsListIdSchemasSchemaIdPut = (
    listId: string,
    schemaId: string,
    fieldSchemaUpdate: FieldSchemaUpdate,
 ) => {
      
      
      return customInstance<FieldSchemaResponse>(
      {url: `/api/lists/${listId}/schemas/${schemaId}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: fieldSchemaUpdate
    },
      );
    }
  


export const getUpdateSchemaApiListsListIdSchemasSchemaIdPutMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateSchemaApiListsListIdSchemasSchemaIdPut>>, TError,{listId: string;schemaId: string;data: FieldSchemaUpdate}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof updateSchemaApiListsListIdSchemasSchemaIdPut>>, TError,{listId: string;schemaId: string;data: FieldSchemaUpdate}, TContext> => {

const mutationKey = ['updateSchemaApiListsListIdSchemasSchemaIdPut'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateSchemaApiListsListIdSchemasSchemaIdPut>>, {listId: string;schemaId: string;data: FieldSchemaUpdate}> = (props) => {
          const {listId,schemaId,data} = props ?? {};

          return  updateSchemaApiListsListIdSchemasSchemaIdPut(listId,schemaId,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateSchemaApiListsListIdSchemasSchemaIdPutMutationResult = NonNullable<Awaited<ReturnType<typeof updateSchemaApiListsListIdSchemasSchemaIdPut>>>
    export type UpdateSchemaApiListsListIdSchemasSchemaIdPutMutationBody = FieldSchemaUpdate
    export type UpdateSchemaApiListsListIdSchemasSchemaIdPutMutationError = HTTPValidationError

    /**
 * @summary Update Schema
 */
export const useUpdateSchemaApiListsListIdSchemasSchemaIdPut = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateSchemaApiListsListIdSchemasSchemaIdPut>>, TError,{listId: string;schemaId: string;data: FieldSchemaUpdate}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateSchemaApiListsListIdSchemasSchemaIdPut>>,
        TError,
        {listId: string;schemaId: string;data: FieldSchemaUpdate},
        TContext
      > => {

      const mutationOptions = getUpdateSchemaApiListsListIdSchemasSchemaIdPutMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Delete a field schema.

Before deletion, checks if the schema is currently used by any tags.
If used, returns 409 Conflict with tag count. User must unbind schema
from tags before deletion (or implement force delete in future).

If schema is deleted, SchemaField associations are CASCADE deleted
automatically by the database (via ON DELETE CASCADE).

Args:
    list_id: UUID of the parent list
    schema_id: UUID of the schema to delete
    db: Database session (injected)

Returns:
    None (204 No Content on success)

Raises:
    HTTPException 404: Schema not found or belongs to different list
    HTTPException 409: Schema is used by one or more tags

Edge Case Handling:
    - Design doc line 528-530: ON DELETE SET NULL on tags.schema_id
      would allow deletion, but we prevent it here to avoid data loss
    - User must explicitly unbind schema from tags first
    - Future enhancement: Add ?force=true query param to allow deletion
 * @summary Delete Schema
 */
export const deleteSchemaApiListsListIdSchemasSchemaIdDelete = (
    listId: string,
    schemaId: string,
 ) => {
      
      
      return customInstance<void>(
      {url: `/api/lists/${listId}/schemas/${schemaId}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteSchemaApiListsListIdSchemasSchemaIdDeleteMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteSchemaApiListsListIdSchemasSchemaIdDelete>>, TError,{listId: string;schemaId: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof deleteSchemaApiListsListIdSchemasSchemaIdDelete>>, TError,{listId: string;schemaId: string}, TContext> => {

const mutationKey = ['deleteSchemaApiListsListIdSchemasSchemaIdDelete'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteSchemaApiListsListIdSchemasSchemaIdDelete>>, {listId: string;schemaId: string}> = (props) => {
          const {listId,schemaId} = props ?? {};

          return  deleteSchemaApiListsListIdSchemasSchemaIdDelete(listId,schemaId,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteSchemaApiListsListIdSchemasSchemaIdDeleteMutationResult = NonNullable<Awaited<ReturnType<typeof deleteSchemaApiListsListIdSchemasSchemaIdDelete>>>
    
    export type DeleteSchemaApiListsListIdSchemasSchemaIdDeleteMutationError = HTTPValidationError

    /**
 * @summary Delete Schema
 */
export const useDeleteSchemaApiListsListIdSchemasSchemaIdDelete = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteSchemaApiListsListIdSchemasSchemaIdDelete>>, TError,{listId: string;schemaId: string}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteSchemaApiListsListIdSchemasSchemaIdDelete>>,
        TError,
        {listId: string;schemaId: string},
        TContext
      > => {

      const mutationOptions = getDeleteSchemaApiListsListIdSchemasSchemaIdDeleteMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    