/**
 * Generated by orval v7.17.0 ðŸº
 * Do not edit manually.
 * Smart YouTube Bookmarks API
 * 
API for managing YouTube video collections with custom fields, real-time processing, and video enrichment.

## Features

- **Lists** â€“ Create and manage video collections
- **Videos** â€“ Add, import (CSV), export, and manage videos
- **Custom Fields** â€“ Define rating, select, text, and boolean fields
- **Field Schemas** â€“ Create reusable field templates
- **Channels** â€“ Auto-created from video metadata
- **Tags** â€“ Organize videos with custom tags
- **Enrichment** â€“ Transcripts and AI-powered metadata
- **Real-Time Progress** â€“ WebSocket-based import tracking

## Authentication

Currently uses a hardcoded user_id for development. Production deployment requires proper authentication.
    
 * OpenAPI spec version: 0.1.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  CreateSubscriptionApiSubscriptionsPostParams,
  DeleteSubscriptionApiSubscriptionsSubscriptionIdDeleteParams,
  GetSubscriptionApiSubscriptionsSubscriptionIdGetParams,
  GetSubscriptionMatchesApiSubscriptionsSubscriptionIdMatchesGetParams,
  HTTPValidationError,
  ListSubscriptionsApiSubscriptionsGetParams,
  QuotaStatusResponse,
  SubscriptionCreate,
  SubscriptionMatchResponse,
  SubscriptionResponse,
  SubscriptionUpdate,
  SyncResponse,
  SyncSubscriptionApiSubscriptionsSubscriptionIdSyncPostParams,
  UpdateSubscriptionApiSubscriptionsSubscriptionIdPutParams
} from '.././model';

import { customInstance } from '../../../lib/axios-instance';




/**
 * List all subscriptions for the current user.

Supports filtering by target list and active status.
Results are ordered by creation date (newest first).
 * @summary List Subscriptions
 */
export const listSubscriptionsApiSubscriptionsGet = (
    params?: ListSubscriptionsApiSubscriptionsGetParams,
 signal?: AbortSignal
) => {
      
      
      return customInstance<SubscriptionResponse[]>(
      {url: `/api/subscriptions`, method: 'GET',
        params, signal
    },
      );
    }
  



export const getListSubscriptionsApiSubscriptionsGetQueryKey = (params?: ListSubscriptionsApiSubscriptionsGetParams,) => {
    return [
    `/api/subscriptions`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getListSubscriptionsApiSubscriptionsGetQueryOptions = <TData = Awaited<ReturnType<typeof listSubscriptionsApiSubscriptionsGet>>, TError = HTTPValidationError>(params?: ListSubscriptionsApiSubscriptionsGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listSubscriptionsApiSubscriptionsGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListSubscriptionsApiSubscriptionsGetQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listSubscriptionsApiSubscriptionsGet>>> = ({ signal }) => listSubscriptionsApiSubscriptionsGet(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listSubscriptionsApiSubscriptionsGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ListSubscriptionsApiSubscriptionsGetQueryResult = NonNullable<Awaited<ReturnType<typeof listSubscriptionsApiSubscriptionsGet>>>
export type ListSubscriptionsApiSubscriptionsGetQueryError = HTTPValidationError


export function useListSubscriptionsApiSubscriptionsGet<TData = Awaited<ReturnType<typeof listSubscriptionsApiSubscriptionsGet>>, TError = HTTPValidationError>(
 params: undefined |  ListSubscriptionsApiSubscriptionsGetParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof listSubscriptionsApiSubscriptionsGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listSubscriptionsApiSubscriptionsGet>>,
          TError,
          Awaited<ReturnType<typeof listSubscriptionsApiSubscriptionsGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useListSubscriptionsApiSubscriptionsGet<TData = Awaited<ReturnType<typeof listSubscriptionsApiSubscriptionsGet>>, TError = HTTPValidationError>(
 params?: ListSubscriptionsApiSubscriptionsGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listSubscriptionsApiSubscriptionsGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listSubscriptionsApiSubscriptionsGet>>,
          TError,
          Awaited<ReturnType<typeof listSubscriptionsApiSubscriptionsGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useListSubscriptionsApiSubscriptionsGet<TData = Awaited<ReturnType<typeof listSubscriptionsApiSubscriptionsGet>>, TError = HTTPValidationError>(
 params?: ListSubscriptionsApiSubscriptionsGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listSubscriptionsApiSubscriptionsGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary List Subscriptions
 */

export function useListSubscriptionsApiSubscriptionsGet<TData = Awaited<ReturnType<typeof listSubscriptionsApiSubscriptionsGet>>, TError = HTTPValidationError>(
 params?: ListSubscriptionsApiSubscriptionsGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listSubscriptionsApiSubscriptionsGet>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getListSubscriptionsApiSubscriptionsGetQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Create a new subscription.

A subscription monitors YouTube channels and/or keywords for new videos
and automatically imports matching videos to the specified list.
 * @summary Create Subscription
 */
export const createSubscriptionApiSubscriptionsPost = (
    subscriptionCreate: SubscriptionCreate,
    params?: CreateSubscriptionApiSubscriptionsPostParams,
 signal?: AbortSignal
) => {
      
      
      return customInstance<SubscriptionResponse>(
      {url: `/api/subscriptions`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: subscriptionCreate,
        params, signal
    },
      );
    }
  


export const getCreateSubscriptionApiSubscriptionsPostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createSubscriptionApiSubscriptionsPost>>, TError,{data: SubscriptionCreate;params?: CreateSubscriptionApiSubscriptionsPostParams}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof createSubscriptionApiSubscriptionsPost>>, TError,{data: SubscriptionCreate;params?: CreateSubscriptionApiSubscriptionsPostParams}, TContext> => {

const mutationKey = ['createSubscriptionApiSubscriptionsPost'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createSubscriptionApiSubscriptionsPost>>, {data: SubscriptionCreate;params?: CreateSubscriptionApiSubscriptionsPostParams}> = (props) => {
          const {data,params} = props ?? {};

          return  createSubscriptionApiSubscriptionsPost(data,params,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateSubscriptionApiSubscriptionsPostMutationResult = NonNullable<Awaited<ReturnType<typeof createSubscriptionApiSubscriptionsPost>>>
    export type CreateSubscriptionApiSubscriptionsPostMutationBody = SubscriptionCreate
    export type CreateSubscriptionApiSubscriptionsPostMutationError = HTTPValidationError

    /**
 * @summary Create Subscription
 */
export const useCreateSubscriptionApiSubscriptionsPost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createSubscriptionApiSubscriptionsPost>>, TError,{data: SubscriptionCreate;params?: CreateSubscriptionApiSubscriptionsPostParams}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createSubscriptionApiSubscriptionsPost>>,
        TError,
        {data: SubscriptionCreate;params?: CreateSubscriptionApiSubscriptionsPostParams},
        TContext
      > => {

      const mutationOptions = getCreateSubscriptionApiSubscriptionsPostMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Get current YouTube API quota status.

Returns the daily usage, remaining quota, and percentage used.
YouTube API has a default daily limit of 10,000 units.

Common API costs:
- Search API: 100 units per request
- Videos list: 1 unit per request
 * @summary Get Quota Status
 */
export const getQuotaStatusApiSubscriptionsQuotaGet = (
    
 signal?: AbortSignal
) => {
      
      
      return customInstance<QuotaStatusResponse>(
      {url: `/api/subscriptions/quota`, method: 'GET', signal
    },
      );
    }
  



export const getGetQuotaStatusApiSubscriptionsQuotaGetQueryKey = () => {
    return [
    `/api/subscriptions/quota`
    ] as const;
    }

    
export const getGetQuotaStatusApiSubscriptionsQuotaGetQueryOptions = <TData = Awaited<ReturnType<typeof getQuotaStatusApiSubscriptionsQuotaGet>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getQuotaStatusApiSubscriptionsQuotaGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetQuotaStatusApiSubscriptionsQuotaGetQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getQuotaStatusApiSubscriptionsQuotaGet>>> = ({ signal }) => getQuotaStatusApiSubscriptionsQuotaGet(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getQuotaStatusApiSubscriptionsQuotaGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetQuotaStatusApiSubscriptionsQuotaGetQueryResult = NonNullable<Awaited<ReturnType<typeof getQuotaStatusApiSubscriptionsQuotaGet>>>
export type GetQuotaStatusApiSubscriptionsQuotaGetQueryError = unknown


export function useGetQuotaStatusApiSubscriptionsQuotaGet<TData = Awaited<ReturnType<typeof getQuotaStatusApiSubscriptionsQuotaGet>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getQuotaStatusApiSubscriptionsQuotaGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getQuotaStatusApiSubscriptionsQuotaGet>>,
          TError,
          Awaited<ReturnType<typeof getQuotaStatusApiSubscriptionsQuotaGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetQuotaStatusApiSubscriptionsQuotaGet<TData = Awaited<ReturnType<typeof getQuotaStatusApiSubscriptionsQuotaGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getQuotaStatusApiSubscriptionsQuotaGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getQuotaStatusApiSubscriptionsQuotaGet>>,
          TError,
          Awaited<ReturnType<typeof getQuotaStatusApiSubscriptionsQuotaGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetQuotaStatusApiSubscriptionsQuotaGet<TData = Awaited<ReturnType<typeof getQuotaStatusApiSubscriptionsQuotaGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getQuotaStatusApiSubscriptionsQuotaGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get Quota Status
 */

export function useGetQuotaStatusApiSubscriptionsQuotaGet<TData = Awaited<ReturnType<typeof getQuotaStatusApiSubscriptionsQuotaGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getQuotaStatusApiSubscriptionsQuotaGet>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetQuotaStatusApiSubscriptionsQuotaGetQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Get a single subscription by ID.
 * @summary Get Subscription
 */
export const getSubscriptionApiSubscriptionsSubscriptionIdGet = (
    subscriptionId: string,
    params?: GetSubscriptionApiSubscriptionsSubscriptionIdGetParams,
 signal?: AbortSignal
) => {
      
      
      return customInstance<SubscriptionResponse>(
      {url: `/api/subscriptions/${subscriptionId}`, method: 'GET',
        params, signal
    },
      );
    }
  



export const getGetSubscriptionApiSubscriptionsSubscriptionIdGetQueryKey = (subscriptionId?: string,
    params?: GetSubscriptionApiSubscriptionsSubscriptionIdGetParams,) => {
    return [
    `/api/subscriptions/${subscriptionId}`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getGetSubscriptionApiSubscriptionsSubscriptionIdGetQueryOptions = <TData = Awaited<ReturnType<typeof getSubscriptionApiSubscriptionsSubscriptionIdGet>>, TError = HTTPValidationError>(subscriptionId: string,
    params?: GetSubscriptionApiSubscriptionsSubscriptionIdGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSubscriptionApiSubscriptionsSubscriptionIdGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetSubscriptionApiSubscriptionsSubscriptionIdGetQueryKey(subscriptionId,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getSubscriptionApiSubscriptionsSubscriptionIdGet>>> = ({ signal }) => getSubscriptionApiSubscriptionsSubscriptionIdGet(subscriptionId,params, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(subscriptionId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getSubscriptionApiSubscriptionsSubscriptionIdGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetSubscriptionApiSubscriptionsSubscriptionIdGetQueryResult = NonNullable<Awaited<ReturnType<typeof getSubscriptionApiSubscriptionsSubscriptionIdGet>>>
export type GetSubscriptionApiSubscriptionsSubscriptionIdGetQueryError = HTTPValidationError


export function useGetSubscriptionApiSubscriptionsSubscriptionIdGet<TData = Awaited<ReturnType<typeof getSubscriptionApiSubscriptionsSubscriptionIdGet>>, TError = HTTPValidationError>(
 subscriptionId: string,
    params: undefined |  GetSubscriptionApiSubscriptionsSubscriptionIdGetParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSubscriptionApiSubscriptionsSubscriptionIdGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSubscriptionApiSubscriptionsSubscriptionIdGet>>,
          TError,
          Awaited<ReturnType<typeof getSubscriptionApiSubscriptionsSubscriptionIdGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetSubscriptionApiSubscriptionsSubscriptionIdGet<TData = Awaited<ReturnType<typeof getSubscriptionApiSubscriptionsSubscriptionIdGet>>, TError = HTTPValidationError>(
 subscriptionId: string,
    params?: GetSubscriptionApiSubscriptionsSubscriptionIdGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSubscriptionApiSubscriptionsSubscriptionIdGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSubscriptionApiSubscriptionsSubscriptionIdGet>>,
          TError,
          Awaited<ReturnType<typeof getSubscriptionApiSubscriptionsSubscriptionIdGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetSubscriptionApiSubscriptionsSubscriptionIdGet<TData = Awaited<ReturnType<typeof getSubscriptionApiSubscriptionsSubscriptionIdGet>>, TError = HTTPValidationError>(
 subscriptionId: string,
    params?: GetSubscriptionApiSubscriptionsSubscriptionIdGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSubscriptionApiSubscriptionsSubscriptionIdGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get Subscription
 */

export function useGetSubscriptionApiSubscriptionsSubscriptionIdGet<TData = Awaited<ReturnType<typeof getSubscriptionApiSubscriptionsSubscriptionIdGet>>, TError = HTTPValidationError>(
 subscriptionId: string,
    params?: GetSubscriptionApiSubscriptionsSubscriptionIdGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSubscriptionApiSubscriptionsSubscriptionIdGet>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetSubscriptionApiSubscriptionsSubscriptionIdGetQueryOptions(subscriptionId,params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update a subscription.

Can modify name, active status, channels, keywords, filters, and poll interval.
 * @summary Update Subscription
 */
export const updateSubscriptionApiSubscriptionsSubscriptionIdPut = (
    subscriptionId: string,
    subscriptionUpdate: SubscriptionUpdate,
    params?: UpdateSubscriptionApiSubscriptionsSubscriptionIdPutParams,
 ) => {
      
      
      return customInstance<SubscriptionResponse>(
      {url: `/api/subscriptions/${subscriptionId}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: subscriptionUpdate,
        params
    },
      );
    }
  


export const getUpdateSubscriptionApiSubscriptionsSubscriptionIdPutMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateSubscriptionApiSubscriptionsSubscriptionIdPut>>, TError,{subscriptionId: string;data: SubscriptionUpdate;params?: UpdateSubscriptionApiSubscriptionsSubscriptionIdPutParams}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof updateSubscriptionApiSubscriptionsSubscriptionIdPut>>, TError,{subscriptionId: string;data: SubscriptionUpdate;params?: UpdateSubscriptionApiSubscriptionsSubscriptionIdPutParams}, TContext> => {

const mutationKey = ['updateSubscriptionApiSubscriptionsSubscriptionIdPut'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateSubscriptionApiSubscriptionsSubscriptionIdPut>>, {subscriptionId: string;data: SubscriptionUpdate;params?: UpdateSubscriptionApiSubscriptionsSubscriptionIdPutParams}> = (props) => {
          const {subscriptionId,data,params} = props ?? {};

          return  updateSubscriptionApiSubscriptionsSubscriptionIdPut(subscriptionId,data,params,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateSubscriptionApiSubscriptionsSubscriptionIdPutMutationResult = NonNullable<Awaited<ReturnType<typeof updateSubscriptionApiSubscriptionsSubscriptionIdPut>>>
    export type UpdateSubscriptionApiSubscriptionsSubscriptionIdPutMutationBody = SubscriptionUpdate
    export type UpdateSubscriptionApiSubscriptionsSubscriptionIdPutMutationError = HTTPValidationError

    /**
 * @summary Update Subscription
 */
export const useUpdateSubscriptionApiSubscriptionsSubscriptionIdPut = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateSubscriptionApiSubscriptionsSubscriptionIdPut>>, TError,{subscriptionId: string;data: SubscriptionUpdate;params?: UpdateSubscriptionApiSubscriptionsSubscriptionIdPutParams}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateSubscriptionApiSubscriptionsSubscriptionIdPut>>,
        TError,
        {subscriptionId: string;data: SubscriptionUpdate;params?: UpdateSubscriptionApiSubscriptionsSubscriptionIdPutParams},
        TContext
      > => {

      const mutationOptions = getUpdateSubscriptionApiSubscriptionsSubscriptionIdPutMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Delete a subscription.
 * @summary Delete Subscription
 */
export const deleteSubscriptionApiSubscriptionsSubscriptionIdDelete = (
    subscriptionId: string,
    params?: DeleteSubscriptionApiSubscriptionsSubscriptionIdDeleteParams,
 ) => {
      
      
      return customInstance<void>(
      {url: `/api/subscriptions/${subscriptionId}`, method: 'DELETE',
        params
    },
      );
    }
  


export const getDeleteSubscriptionApiSubscriptionsSubscriptionIdDeleteMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteSubscriptionApiSubscriptionsSubscriptionIdDelete>>, TError,{subscriptionId: string;params?: DeleteSubscriptionApiSubscriptionsSubscriptionIdDeleteParams}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof deleteSubscriptionApiSubscriptionsSubscriptionIdDelete>>, TError,{subscriptionId: string;params?: DeleteSubscriptionApiSubscriptionsSubscriptionIdDeleteParams}, TContext> => {

const mutationKey = ['deleteSubscriptionApiSubscriptionsSubscriptionIdDelete'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteSubscriptionApiSubscriptionsSubscriptionIdDelete>>, {subscriptionId: string;params?: DeleteSubscriptionApiSubscriptionsSubscriptionIdDeleteParams}> = (props) => {
          const {subscriptionId,params} = props ?? {};

          return  deleteSubscriptionApiSubscriptionsSubscriptionIdDelete(subscriptionId,params,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteSubscriptionApiSubscriptionsSubscriptionIdDeleteMutationResult = NonNullable<Awaited<ReturnType<typeof deleteSubscriptionApiSubscriptionsSubscriptionIdDelete>>>
    
    export type DeleteSubscriptionApiSubscriptionsSubscriptionIdDeleteMutationError = HTTPValidationError

    /**
 * @summary Delete Subscription
 */
export const useDeleteSubscriptionApiSubscriptionsSubscriptionIdDelete = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteSubscriptionApiSubscriptionsSubscriptionIdDelete>>, TError,{subscriptionId: string;params?: DeleteSubscriptionApiSubscriptionsSubscriptionIdDeleteParams}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteSubscriptionApiSubscriptionsSubscriptionIdDelete>>,
        TError,
        {subscriptionId: string;params?: DeleteSubscriptionApiSubscriptionsSubscriptionIdDeleteParams},
        TContext
      > => {

      const mutationOptions = getDeleteSubscriptionApiSubscriptionsSubscriptionIdDeleteMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Manually trigger sync for a subscription.

Checks for new videos matching the subscription criteria
and imports them to the target list.

Note: This is currently a stub. Full implementation in Etappe 2.
 * @summary Sync Subscription
 */
export const syncSubscriptionApiSubscriptionsSubscriptionIdSyncPost = (
    subscriptionId: string,
    params?: SyncSubscriptionApiSubscriptionsSubscriptionIdSyncPostParams,
 signal?: AbortSignal
) => {
      
      
      return customInstance<SyncResponse>(
      {url: `/api/subscriptions/${subscriptionId}/sync`, method: 'POST',
        params, signal
    },
      );
    }
  


export const getSyncSubscriptionApiSubscriptionsSubscriptionIdSyncPostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof syncSubscriptionApiSubscriptionsSubscriptionIdSyncPost>>, TError,{subscriptionId: string;params?: SyncSubscriptionApiSubscriptionsSubscriptionIdSyncPostParams}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof syncSubscriptionApiSubscriptionsSubscriptionIdSyncPost>>, TError,{subscriptionId: string;params?: SyncSubscriptionApiSubscriptionsSubscriptionIdSyncPostParams}, TContext> => {

const mutationKey = ['syncSubscriptionApiSubscriptionsSubscriptionIdSyncPost'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof syncSubscriptionApiSubscriptionsSubscriptionIdSyncPost>>, {subscriptionId: string;params?: SyncSubscriptionApiSubscriptionsSubscriptionIdSyncPostParams}> = (props) => {
          const {subscriptionId,params} = props ?? {};

          return  syncSubscriptionApiSubscriptionsSubscriptionIdSyncPost(subscriptionId,params,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SyncSubscriptionApiSubscriptionsSubscriptionIdSyncPostMutationResult = NonNullable<Awaited<ReturnType<typeof syncSubscriptionApiSubscriptionsSubscriptionIdSyncPost>>>
    
    export type SyncSubscriptionApiSubscriptionsSubscriptionIdSyncPostMutationError = HTTPValidationError

    /**
 * @summary Sync Subscription
 */
export const useSyncSubscriptionApiSubscriptionsSubscriptionIdSyncPost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof syncSubscriptionApiSubscriptionsSubscriptionIdSyncPost>>, TError,{subscriptionId: string;params?: SyncSubscriptionApiSubscriptionsSubscriptionIdSyncPostParams}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof syncSubscriptionApiSubscriptionsSubscriptionIdSyncPost>>,
        TError,
        {subscriptionId: string;params?: SyncSubscriptionApiSubscriptionsSubscriptionIdSyncPostParams},
        TContext
      > => {

      const mutationOptions = getSyncSubscriptionApiSubscriptionsSubscriptionIdSyncPostMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Get match history for a subscription.

Returns the list of videos that were imported by this subscription.
 * @summary Get Subscription Matches
 */
export const getSubscriptionMatchesApiSubscriptionsSubscriptionIdMatchesGet = (
    subscriptionId: string,
    params?: GetSubscriptionMatchesApiSubscriptionsSubscriptionIdMatchesGetParams,
 signal?: AbortSignal
) => {
      
      
      return customInstance<SubscriptionMatchResponse[]>(
      {url: `/api/subscriptions/${subscriptionId}/matches`, method: 'GET',
        params, signal
    },
      );
    }
  



export const getGetSubscriptionMatchesApiSubscriptionsSubscriptionIdMatchesGetQueryKey = (subscriptionId?: string,
    params?: GetSubscriptionMatchesApiSubscriptionsSubscriptionIdMatchesGetParams,) => {
    return [
    `/api/subscriptions/${subscriptionId}/matches`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getGetSubscriptionMatchesApiSubscriptionsSubscriptionIdMatchesGetQueryOptions = <TData = Awaited<ReturnType<typeof getSubscriptionMatchesApiSubscriptionsSubscriptionIdMatchesGet>>, TError = HTTPValidationError>(subscriptionId: string,
    params?: GetSubscriptionMatchesApiSubscriptionsSubscriptionIdMatchesGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSubscriptionMatchesApiSubscriptionsSubscriptionIdMatchesGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetSubscriptionMatchesApiSubscriptionsSubscriptionIdMatchesGetQueryKey(subscriptionId,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getSubscriptionMatchesApiSubscriptionsSubscriptionIdMatchesGet>>> = ({ signal }) => getSubscriptionMatchesApiSubscriptionsSubscriptionIdMatchesGet(subscriptionId,params, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(subscriptionId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getSubscriptionMatchesApiSubscriptionsSubscriptionIdMatchesGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetSubscriptionMatchesApiSubscriptionsSubscriptionIdMatchesGetQueryResult = NonNullable<Awaited<ReturnType<typeof getSubscriptionMatchesApiSubscriptionsSubscriptionIdMatchesGet>>>
export type GetSubscriptionMatchesApiSubscriptionsSubscriptionIdMatchesGetQueryError = HTTPValidationError


export function useGetSubscriptionMatchesApiSubscriptionsSubscriptionIdMatchesGet<TData = Awaited<ReturnType<typeof getSubscriptionMatchesApiSubscriptionsSubscriptionIdMatchesGet>>, TError = HTTPValidationError>(
 subscriptionId: string,
    params: undefined |  GetSubscriptionMatchesApiSubscriptionsSubscriptionIdMatchesGetParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSubscriptionMatchesApiSubscriptionsSubscriptionIdMatchesGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSubscriptionMatchesApiSubscriptionsSubscriptionIdMatchesGet>>,
          TError,
          Awaited<ReturnType<typeof getSubscriptionMatchesApiSubscriptionsSubscriptionIdMatchesGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetSubscriptionMatchesApiSubscriptionsSubscriptionIdMatchesGet<TData = Awaited<ReturnType<typeof getSubscriptionMatchesApiSubscriptionsSubscriptionIdMatchesGet>>, TError = HTTPValidationError>(
 subscriptionId: string,
    params?: GetSubscriptionMatchesApiSubscriptionsSubscriptionIdMatchesGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSubscriptionMatchesApiSubscriptionsSubscriptionIdMatchesGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSubscriptionMatchesApiSubscriptionsSubscriptionIdMatchesGet>>,
          TError,
          Awaited<ReturnType<typeof getSubscriptionMatchesApiSubscriptionsSubscriptionIdMatchesGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetSubscriptionMatchesApiSubscriptionsSubscriptionIdMatchesGet<TData = Awaited<ReturnType<typeof getSubscriptionMatchesApiSubscriptionsSubscriptionIdMatchesGet>>, TError = HTTPValidationError>(
 subscriptionId: string,
    params?: GetSubscriptionMatchesApiSubscriptionsSubscriptionIdMatchesGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSubscriptionMatchesApiSubscriptionsSubscriptionIdMatchesGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get Subscription Matches
 */

export function useGetSubscriptionMatchesApiSubscriptionsSubscriptionIdMatchesGet<TData = Awaited<ReturnType<typeof getSubscriptionMatchesApiSubscriptionsSubscriptionIdMatchesGet>>, TError = HTTPValidationError>(
 subscriptionId: string,
    params?: GetSubscriptionMatchesApiSubscriptionsSubscriptionIdMatchesGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSubscriptionMatchesApiSubscriptionsSubscriptionIdMatchesGet>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetSubscriptionMatchesApiSubscriptionsSubscriptionIdMatchesGetQueryOptions(subscriptionId,params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




