# Task #186: Create documentation for Vault integration

**Plan Task:** #186
**Wave/Phase:** Phase 1 Security Hardening, Task 10 (Future Implementation)
**Dependencies:** Task #155 (Docker Compose env vars), Task #156 (Config secret validation)

---

## ðŸŽ¯ Ziel

Document a comprehensive, production-ready secret management strategy for Smart YouTube Bookmarks, covering HashiCorp Vault, AWS Secrets Manager, and Kubernetes Secrets integrations. Provide architectural guidance, code examples, and security checklists to enable future implementation of enterprise-grade secret management without maintaining secrets in version control or environment files.

**Success Criteria:**
- Complete documentation in `docs/deployment/SECRET_MANAGEMENT.md`
- Comparison table: Vault vs AWS vs K8s with decision framework
- Python code examples for Vault integration (commented as future implementation)
- Security compliance checklist (8+ items, OWASP-aligned)
- Secret rotation strategy for database, JWT, and API keys
- Implementation roadmap with 3 phases and timeline estimates

---

## ðŸ“‹ Acceptance Criteria

- [ ] Secret management documentation created with 4 major sections
- [ ] Vault/AWS/K8s comparison table with pros/cons
- [ ] Python hvac client integration examples (backend/app/core/vault.py outline)
- [ ] Security checklist with 8+ production requirements
- [ ] Secret rotation strategy documented (database, JWT, API keys)
- [ ] REF MCP research findings integrated (hvac library, boto3)
- [ ] Implementation roadmap with estimated effort (3 phases)
- [ ] Testing strategy for secret management systems
- [ ] Code review guidelines for secret handling
- [ ] Documentation matches OWASP Secrets Management standards

---

## ðŸ› ï¸ Implementation Steps

### 1. Research and validate Vault/AWS/K8s approaches
**Files:** Research phase (no files created)
**Action:** Review hvac documentation, AWS Secrets Manager SDK, and Kubernetes Secrets patterns

**Key Findings from REF MCP:**
- **hvac library (Python Vault Client):**
  - Official Python 3.X client for HashiCorp Vault (v1.4.7+)
  - Supports multiple auth methods: AppRole, Kubernetes, JWT/OIDC, LDAP, AWS IAM
  - KV v1 and v2 secrets engines supported
  - Version 2.4.0+ with comprehensive HTTP adapter support
  - Can be used with async frameworks via custom adapters
  - Reference: https://python-hvac.org/

- **AWS Secrets Manager (Python boto3):**
  - Native AWS integration via `boto3.client('secretsmanager')`
  - Client-side caching available (faster retrieval, reduced API calls)
  - IAM-based access control with resource-level policies
  - Automatic rotation support (Lambda-based or built-in)
  - KMS encryption by default
  - Reference: https://docs.aws.amazon.com/secretsmanager/latest/userguide/retrieving-secrets-python.html

- **Kubernetes Secrets + External Secrets Operator:**
  - External Secrets Operator (ESO) integrates Vault/AWS/GCP with K8s
  - Automatic secret synchronization
  - RBAC for pod access control
  - Pod Security Standards (PSS) enforcement
  - Reference: https://external-secrets.io/

### 2. Create comprehensive SECRET_MANAGEMENT.md documentation
**Files:** `docs/deployment/SECRET_MANAGEMENT.md`
**Action:** Write documentation following structure below

**Document Outline:**

```markdown
# Secret Management Strategy

## 1. Current State (Development)
- .env file approach (generated by scripts/generate_secrets.py)
- Never committed to version control
- Development-only limitations documented
- Transition path to production

## 2. Architecture Decision Matrix
### Option Comparison Table
| Feature | Vault | AWS Secrets Manager | K8s Secrets |
|---------|-------|-------------------|-------------|
| Setup Complexity | Medium (server + auth) | Low (AWS account) | Low (K8s extension) |
| Dynamic Secrets | Yes (auto-rotation) | Yes (auto-rotation) | No (static) |
| Audit Logging | Comprehensive | CloudTrail + native | Audit policy |
| Cost | Self-hosted | Pay-per-secret | Included in K8s |
| Auth Methods | 15+ methods | IAM only | ServiceAccount + RBAC |
| Encryption Transit | TLS enforced | TLS enforced | TLS enforced |
| Encryption Rest | Yes (Shamir keys) | KMS required | KMS required |
| Secret Rotation | Manual or automatic | Automatic | Manual |
| Disaster Recovery | Snapshots + Raft | AWS managed | etcd backup |
| Multi-Region | Manual replication | Built-in | Manual |
| DevOps Learning Curve | High | Low (AWS ecosystem) | Medium |

### Decision Framework
- **Vault:** Best for multi-cloud, on-premise, complex auth requirements
- **AWS Secrets Manager:** Best for AWS-native workloads, Lambda, ECS
- **K8s Secrets:** Best for Kubernetes-only deployments, cost-conscious

## 3. Implementation Roadmap (3 Phases)

### Phase 1: Vault Integration (6-8 weeks)
1. Set up self-hosted or cloud-hosted Vault
2. Create app role for backend service
3. Implement hvac client in app/core/vault.py
4. Update Settings class to fetch from Vault
5. Add Vault health check to /api/health
6. Write tests for Vault client

### Phase 2: Secret Rotation (4-6 weeks)
1. Database password rotation (blue/green)
2. API key rotation schedule
3. JWT secret rotation strategy
4. Update ARQ workers for key rotation
5. Document rotation procedures

### Phase 3: Audit & Compliance (2-4 weeks)
1. Enable Vault audit logging
2. Set up CloudTrail for AWS Secrets Manager
3. Create compliance reporting dashboard
4. Document OWASP compliance checklist
5. Train team on secret management

## 4. Recommended: HashiCorp Vault
[Detailed Vault documentation section]

## 5. Alternative: AWS Secrets Manager
[Detailed AWS documentation section]

## 6. Alternative: Kubernetes Secrets + ESO
[Detailed K8s documentation section]

## 7. Security Checklist
[OWASP-aligned checklist with 8+ items]

## 8. Secret Rotation Strategy
[Detailed rotation procedures]

## 9. Current Workaround (Development)
[How to safely handle secrets until production setup]

## 10. Resources
[Links to official documentation]
```

### 3. Create implementation code examples
**Files:** Documentation with code snippets (commented as future implementation)
**Action:** Include Python code examples for Vault integration

**Example: backend/app/core/vault.py (Future Implementation)**

```python
"""
HashiCorp Vault client for secret management.

This module provides a Vault client for reading and managing secrets
in production environments. It implements connection pooling, caching,
and error handling for production-grade secret management.

Future implementation: Uncomment when Vault is deployed.
Status: Documentation phase only
"""

# Future implementation example:
#
# import os
# import hvac
# from typing import Optional, Dict, Any
# from functools import lru_cache
# import logging
#
# logger = logging.getLogger(__name__)
#
#
# class VaultClient:
#     """
#     Vault client wrapper for secret management.
#
#     Features:
#     - Connection pooling
#     - Token refresh
#     - Error handling with fallback
#     - Audit logging
#     """
#
#     def __init__(
#         self,
#         url: str,
#         namespace: str = "smart-youtube-bookmarks",
#         auth_method: str = "approle"
#     ):
#         """
#         Initialize Vault client.
#
#         Args:
#             url: Vault server URL (e.g., https://vault.example.com:8200)
#             namespace: Vault namespace for this application
#             auth_method: Authentication method ('approle', 'kubernetes', 'jwt')
#         """
#         self.url = url
#         self.namespace = namespace
#         self.auth_method = auth_method
#         self.client = hvac.Client(
#             url=url,
#             namespace=namespace,
#             verify=True  # Always verify TLS in production
#         )
#
#     def authenticate_approle(self, role_id: str, secret_id: str) -> bool:
#         """
#         Authenticate using AppRole auth method (recommended for services).
#
#         AppRole is ideal for microservices because:
#         - Uses role_id (non-secret) + secret_id (secret)
#         - Allows credential rotation without downtime
#         - Service can pull its own credentials from secure location
#
#         Args:
#             role_id: AppRole role ID (can be in code)
#             secret_id: AppRole secret ID (from secure storage)
#
#         Returns:
#             True if authentication successful
#         """
#         try:
#             self.client.auth.approle.login(role_id, secret_id)
#             logger.info("AppRole authentication successful")
#             return True
#         except hvac.exceptions.Unauthorized as e:
#             logger.error(f"AppRole authentication failed: {e}")
#             return False
#
#     def authenticate_kubernetes(self, jwt_token: str, role: str) -> bool:
#         """
#         Authenticate using Kubernetes auth method (for K8s deployments).
#
#         Args:
#             jwt_token: ServiceAccount JWT token
#             role: Kubernetes auth role
#
#         Returns:
#             True if authentication successful
#         """
#         try:
#             self.client.auth.kubernetes.login(role, jwt_token)
#             logger.info("Kubernetes authentication successful")
#             return True
#         except hvac.exceptions.Unauthorized as e:
#             logger.error(f"Kubernetes authentication failed: {e}")
#             return False
#
#     def read_secret(self, path: str, key: Optional[str] = None) -> Any:
#         """
#         Read secret from Vault KV v2 secrets engine.
#
#         Args:
#             path: Secret path (e.g., 'secret/data/database/prod')
#             key: Optional specific field to extract
#
#         Returns:
#             Secret value or dict of all fields
#         """
#         try:
#             response = self.client.secrets.kv.v2.read_secret_version(
#                 path=path,
#                 mount_point="secret"
#             )
#             data = response['data']['data']
#
#             if key:
#                 return data.get(key)
#             return data
#         except hvac.exceptions.InvalidPath as e:
#             logger.error(f"Secret not found at {path}: {e}")
#             raise
#         except hvac.exceptions.Forbidden as e:
#             logger.error(f"Access denied for {path}: {e}")
#             raise
#
#     def write_secret(self, path: str, data: Dict[str, Any]) -> bool:
#         """
#         Write secret to Vault (for testing/setup only).
#
#         Args:
#             path: Secret path
#             data: Secret data
#
#         Returns:
#             True if successful
#         """
#         try:
#             self.client.secrets.kv.v2.create_or_update_secret(
#                 path=path,
#                 secret=data,
#                 mount_point="secret"
#             )
#             logger.info(f"Secret written to {path}")
#             return True
#         except Exception as e:
#             logger.error(f"Failed to write secret: {e}")
#             return False
#
#     def delete_secret(self, path: str) -> bool:
#         """
#         Delete secret from Vault (use with caution).
#
#         Args:
#             path: Secret path
#
#         Returns:
#             True if successful
#         """
#         try:
#             self.client.secrets.kv.v2.delete_secret_version(
#                 path=path,
#                 mount_point="secret"
#             )
#             logger.info(f"Secret deleted: {path}")
#             return True
#         except Exception as e:
#             logger.error(f"Failed to delete secret: {e}")
#             return False
#
#     def get_database_credentials(self) -> Dict[str, str]:
#         """
#         Get dynamic database credentials from Vault.
#
#         Vault can generate temporary DB credentials that expire automatically.
#
#         Returns:
#             Dict with 'username' and 'password' keys
#         """
#         try:
#             response = self.client.secrets.databases.generate_credentials(
#                 name="youtube-bookmarks-db-role"
#             )
#             return {
#                 "username": response['data']['username'],
#                 "password": response['data']['password']
#             }
#         except Exception as e:
#             logger.error(f"Failed to generate DB credentials: {e}")
#             raise
#
#
# # Integration with Settings class:
# class VaultSettings:
#     """
#     Load settings from Vault instead of environment.
#
#     Usage in config.py:
#         from app.core.vault import VaultSettings
#         vault = VaultSettings()
#         settings = vault.load_settings()
#     """
#
#     def __init__(self):
#         self.vault = VaultClient(
#             url=os.getenv("VAULT_ADDR", "https://vault.example.com:8200")
#         )
#         self._authenticate()
#
#     def _authenticate(self):
#         """Authenticate to Vault using AppRole or K8s auth."""
#         # Try AppRole first (for non-K8s environments)
#         role_id = os.getenv("VAULT_ROLE_ID")
#         secret_id = os.getenv("VAULT_SECRET_ID")
#
#         if role_id and secret_id:
#             self.vault.authenticate_approle(role_id, secret_id)
#         else:
#             # Fall back to Kubernetes auth
#             with open("/var/run/secrets/kubernetes.io/serviceaccount/token") as f:
#                 token = f.read()
#             self.vault.authenticate_kubernetes(
#                 token,
#                 role=os.getenv("VAULT_K8S_ROLE", "app-role")
#             )
#
#     def load_settings(self) -> Dict[str, Any]:
#         """Load all application settings from Vault."""
#         return {
#             "database_url": self.vault.read_secret(
#                 "secret/database/prod", "url"
#             ),
#             "redis_url": self.vault.read_secret(
#                 "secret/redis/prod", "url"
#             ),
#             "youtube_api_key": self.vault.read_secret(
#                 "secret/api-keys/youtube", "key"
#             ),
#             "gemini_api_key": self.vault.read_secret(
#                 "secret/api-keys/gemini", "key"
#             ),
#             "secret_key": self.vault.read_secret(
#                 "secret/jwt/prod", "key"
#             ),
#         }
```

### 4. Create security compliance checklist
**Files:** Documentation section
**Action:** Document OWASP-aligned security requirements

**Security Checklist (Production Requirements):**

```markdown
## Production Secret Management Security Checklist

All items must be verified before deploying to production.

### Storage & Encryption
- [ ] Secrets never stored in code repositories (.gitignore: .env, secrets/*)
- [ ] Secrets never committed to version control (git history clean)
- [ ] Encryption at rest enabled (Vault: Shamir keys, AWS: KMS, K8s: etcd encryption)
- [ ] Encryption in transit enforced (TLS 1.2+ only, verified certs)
- [ ] All secret backends use authenticated HTTPS only

### Access Control
- [ ] Least privilege access enforced (principle of least privilege)
- [ ] Service accounts with minimal required permissions
- [ ] AppRole or Kubernetes auth used (no static tokens)
- [ ] RBAC policies defined per application/environment
- [ ] Temporary/time-limited credentials for sensitive operations

### Audit & Monitoring
- [ ] Audit logging enabled on secret access (100% of reads/writes)
- [ ] Audit logs stored separately from operational logs
- [ ] Alert on unauthorized secret access attempts
- [ ] Alert on secret access outside business hours
- [ ] Monthly audit log review process documented

### Rotation & Lifecycle
- [ ] Automated secret rotation scheduled (quarterly minimum)
- [ ] Database credentials rotate without downtime (blue/green)
- [ ] API keys rotated with grace period for clients
- [ ] JWT secrets rotated with token refresh mechanism
- [ ] Rotation procedure tested and documented

### Disaster Recovery
- [ ] Backup & restore procedure documented
- [ ] Backup encryption verified (not just backup storage)
- [ ] Recovery Time Objective (RTO) defined
- [ ] Recovery Point Objective (RPO) defined
- [ ] Annual disaster recovery drill scheduled

### Compliance & Standards
- [ ] OWASP Secrets Management checklist completed
- [ ] CIS Benchmarks for secret management reviewed
- [ ] SOC 2 compliance verified (if applicable)
- [ ] PCI DSS compliance verified (if handling payment data)
- [ ] Documentation includes data classification level

### Operations & Incident Response
- [ ] Incident response plan for credential compromise
- [ ] Escalation path for security incidents
- [ ] Secret revocation procedure defined
- [ ] Team training on secret management completed
- [ ] On-call rotation for secret system outages
```

### 5. Create secret rotation strategy documentation
**Files:** Documentation section
**Action:** Document rotation procedures for database, JWT, and API keys

**Secret Rotation Strategy:**

```markdown
## Secret Rotation Strategy

### 1. Database Password Rotation (Blue/Green Approach)

**Why?** Database passwords are frequently accessed by multiple services.

**Process:**
1. Create new database user with new password (Blue user)
2. Grant same privileges as old user (Green user)
3. Update application secrets to point to Blue user
4. Monitor for errors (2-4 hours)
5. Delete Green user
6. Next cycle: Green becomes Blue

**Timeline:** Quarterly
**Downtime:** None (zero-downtime rotation)
**Testing:** 
- Verify new credentials work
- Test connection pool behavior
- Monitor query performance

### 2. JWT Secret Rotation (Token Refresh)

**Why?** Compromised JWT secret allows creating valid tokens indefinitely.

**Process:**
1. Generate new JWT secret key
2. Keep old secret for 24 hours (token validation)
3. New tokens signed with new secret only
4. After 24 hours, reject old secret
5. Existing tokens expire naturally (30-min TTL)

**Timeline:** Monthly
**Downtime:** None (token lifespan handles transition)
**Testing:**
- Test token generation with new key
- Test existing tokens still validate during grace period
- Verify old tokens rejected after grace period

### 3. API Key Rotation (Client Notification)

**Why?** External API keys (YouTube, Gemini) can be leaked.

**Process:**
1. Create new API key in provider's console
2. Update application config to use new key
3. Monitor for errors (24 hours)
4. Keep old key active for 7 days (client grace period)
5. Notify clients of rotation (if applicable)
6. After 7 days, delete old key

**Timeline:** Every 6 months (or on suspected compromise)
**Downtime:** None (key can be switched in runtime)
**Testing:**
- Verify new key in dev/staging before production
- Test API rate limits with new key
- Monitor for quota issues

### 4. Automated Rotation with Vault

**Example Vault configuration (future):**

```hcl
# Enable database secrets engine
path "database/config/youtube-bookmarks" {
  capabilities = ["create", "read", "update"]
}

# Auto-rotate database user password every 30 days
path "database/roles/youtube-bookmarks-app" {
  capabilities = ["read"]
}

# Database rotation scheduled in Vault policy
# /etc/vault/policies/app-policy.hcl
```

### 5. Rotation Failure Handling

**If rotation fails:**
1. Alert on-call DevOps immediately
2. Retain old secret (don't delete)
3. Investigate root cause
4. Fix and retry rotation
5. Document incident
6. Post-mortem review
```

### 6. Implement testing strategy
**Files:** Documentation section
**Action:** Outline testing approach for secret management

**Testing Strategy:**

```markdown
## Testing Secret Management Systems

### Unit Tests
```python
# backend/tests/core/test_vault.py
def test_vault_client_initialization():
    """Test Vault client can be created."""
    client = VaultClient(url="http://localhost:8200")
    assert client.url == "http://localhost:8200"

def test_vault_authentication_approle():
    """Test AppRole authentication."""
    client = VaultClient(url="http://localhost:8200")
    result = client.authenticate_approle("role-id", "secret-id")
    assert result is True

def test_vault_read_secret():
    """Test reading secret from Vault."""
    client = VaultClient(url="http://localhost:8200")
    client.authenticate_approle("role-id", "secret-id")
    secret = client.read_secret("secret/database/test")
    assert "password" in secret
```

### Integration Tests
- Test with real Vault instance (Docker container)
- Verify secret read/write operations
- Test authentication failure handling
- Test network timeout handling

### Security Tests
- Verify secrets not logged to stdout
- Verify TLS certificate validation
- Test with self-signed certificates
- Verify audit trail contains access records

### Performance Tests
- Measure secret read latency (target: < 100ms)
- Measure batch operations
- Measure connection pool behavior
```

### 7. Create code review guidelines
**Files:** Documentation section
**Action:** Document best practices for code review

**Code Review Guidelines for Secrets:**

```markdown
## Code Review Checklist for Secret Management

Reviewers must verify:

### 1. Never In Code
- [ ] No secrets in commit message
- [ ] No secrets in code comments
- [ ] No secrets in test fixtures
- [ ] No secrets in error messages
- [ ] .env file in .gitignore

### 2. Environment Variables
- [ ] Variable names are descriptive
- [ ] Default values are safe (non-sensitive)
- [ ] Validation checks present
- [ ] Production requires explicit setting

### 3. Vault Integration
- [ ] Client uses authenticated connections only
- [ ] Error handling includes audit logging
- [ ] Connection pooling configured
- [ ] Timeout values are reasonable

### 4. Secret Handling
- [ ] Secrets not logged
- [ ] Secrets cleared from memory after use
- [ ] No string concatenation with secrets
- [ ] No secrets in exception messages

### 5. Testing
- [ ] Tests mock secret calls
- [ ] No real secrets in test fixtures
- [ ] Tests verify error handling
- [ ] Integration tests use real Vault instance
```

### 8. Document recommendations and decision framework
**Files:** Documentation section
**Action:** Provide clear guidance for selecting approach

**Recommendation Summary:**

```markdown
## Recommended Approach: HashiCorp Vault

**Why Vault?**
1. **Multi-platform:** Works on-premise, AWS, Azure, GCP
2. **Flexible auth:** 15+ auth methods (AppRole, Kubernetes, JWT, etc.)
3. **Dynamic secrets:** Can generate temporary DB credentials
4. **Comprehensive audit:** Detailed logging of all operations
5. **No vendor lock-in:** Can migrate away from Vault

**When to choose alternatives:**

| Situation | Recommended | Reason |
|-----------|-------------|--------|
| AWS-only workload | AWS Secrets Manager | Native integration, less ops burden |
| Kubernetes-only | K8s Secrets + ESO | Lower complexity, no extra infrastructure |
| On-premise only | Vault | Full control, no cloud dependency |
| Multi-cloud strategy | Vault | Single system across clouds |
| Small MVP/startup | AWS Secrets Manager | Minimal ops overhead |
| Enterprise with compliance | Vault | Maximum audit control |

**Implementation effort estimate:**
- Vault: 6-8 weeks (setup + integration + testing)
- AWS Secrets Manager: 3-4 weeks (simpler setup)
- K8s Secrets + ESO: 4-5 weeks (requires K8s cluster)
```

---

## ðŸ§ª Testing Strategy

### Documentation Testing
- [ ] REF MCP links verified (hvac, boto3, External Secrets)
- [ ] Code examples run without errors
- [ ] All table references correct
- [ ] Links to OWASP documentation working
- [ ] Markdown formatting validated

### Peer Review
- [ ] Security team reviews checklist
- [ ] DevOps team reviews procedures
- [ ] Compliance reviews against standards
- [ ] Architecture review for design decisions

### Usage Testing
- [ ] Developer can follow guide end-to-end
- [ ] Code examples can be copy-pasted
- [ ] Commands listed actually work
- [ ] Troubleshooting section helpful

---

## ðŸ“š Reference

**Related Docs:**
- `docs/plans/2025-11-02-security-hardening-implementation.md` - Task 10 overview
- `backend/app/core/config.py` - Current Settings implementation
- `CLAUDE.md` - Project conventions and architecture

**REF MCP Research:**
- hvac Python Vault client: https://python-hvac.org/
- AWS Secrets Manager Python: https://docs.aws.amazon.com/secretsmanager/latest/userguide/retrieving-secrets-python.html
- External Secrets Operator: https://external-secrets.io/

**OWASP Standards:**
- Secrets Management Cheat Sheet: https://cheatsheetseries.owasp.org/cheatsheets/Secrets_Management_Cheat_Sheet.html
- Secure Coding Practices: https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/

**Design Decisions:**
- **Why not use environment variables in production?** Environment variables are visible in process listings (`ps aux`) and logs. Vault/AWS provide better isolation.
- **Why AppRole over other auth methods?** AppRole allows zero-knowledge architecture where the app doesn't need initial credentials; they're injected by orchestration platform.
- **Why blue/green for database rotation?** Prevents connection failures during password change by maintaining both users until clients switch over.

**Future Considerations:**
- **Multi-region replication:** Vault Enterprise or multi-region AWS Secrets Manager setup
- **Secret versioning:** Track historical secrets for compliance audits
- **Automated rotation with zero downtime:** Requires application to detect secret changes
- **Cost optimization:** Monitor API call volumes to AWS/GCP Vault services

---

## â±ï¸ Implementation Timeline

**Estimated Effort:** 45-60 minutes for documentation writing

**Breakdown:**
- Research & validation: 10 minutes
- Core documentation (sections 1-3): 20 minutes
- Code examples & templates: 15 minutes
- Checklist & procedures: 10 minutes
- Review & refinement: 10 minutes

**Blocking Issues:** None (documentation-only task)

**Integration Points:**
- Requires input from DevOps team (favorite platform)
- Compliance team should validate checklist
- Security audit should review recommendations
