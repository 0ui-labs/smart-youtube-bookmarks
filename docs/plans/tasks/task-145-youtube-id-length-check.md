# Task #145: Add youtube_id length and format checks

**Plan Task:** #145
**Wave/Phase:** Security Hardening - Database Constraints
**Dependencies:** Task #144 (Database Constraints Skeleton), Task #143 (Kubernetes Health Probes)

---

## üéØ Ziel

Implement CHECK constraints in PostgreSQL to enforce youtube_id data integrity:
1. **Length Constraint:** youtube_id must be exactly 11 characters (YouTube ID standard)
2. **Format Constraint:** youtube_id must contain only alphanumeric characters, hyphens, and underscores (matching YouTube's ID format)

This ensures database-level enforcement of YouTube ID validity, preventing invalid data insertion even if application-level validation is bypassed.

## üìã Acceptance Criteria

- [ ] Alembic migration creates LENGTH CHECK constraint (LENGTH(youtube_id) = 11)
- [ ] Alembic migration creates FORMAT CHECK constraint (regex pattern: ^[a-zA-Z0-9_-]{11}$)
- [ ] Migration UP applies both constraints successfully
- [ ] Migration DOWN removes both constraints without errors
- [ ] Unit tests verify constraint enforcement (invalid IDs rejected)
- [ ] Integration tests verify constraint doesn't block valid videos
- [ ] No existing data violations (all current youtube_ids are 11 chars)
- [ ] Code reviewed and all tests passing

---

## üõ†Ô∏è Implementation Steps

### 1. Generate Alembic Migration File
**Files:** `backend/alembic/versions/XXXX_add_database_constraints.py`
**Action:** Create new migration file with revision ID and reference to previous migration

```bash
cd backend
alembic revision -m "Add database constraints for data integrity"
```

This will generate a file like: `1b2c3d4e5f6g_add_database_constraints.py`

**Key Point:** Note the generated revision ID (e.g., `1b2c3d4e5f6g`) and the down_revision value from the last migration file (currently `1a6e18578c31` from custom fields system).

---

### 2. Implement upgrade() Function
**Files:** `backend/alembic/versions/XXXX_add_database_constraints.py`
**Action:** Add CHECK constraints using op.create_check_constraint()

**Complete Migration Code:**

```python
"""Add database constraints for data integrity

Revision ID: <AUTO-GENERATED>
Revises: 1a6e18578c31
Create Date: 2025-11-10

This migration adds CHECK constraints to enforce data integrity at the database level:

1. youtube_id length: Must be exactly 11 characters (YouTube standard)
2. youtube_id format: Must contain only alphanumeric, hyphen, underscore
3. youtube_url not empty: Must contain at least 1 character
4. list name not empty: Must contain at least 1 character
5. tag name not empty: Must contain at least 1 character
6. user/youtube_id uniqueness: Prevent duplicate videos per user

REF MCP Validation (PostgreSQL 13+):
- LENGTH() function: Returns character count of text values
- Regex operator (~): Matches text against POSIX regex patterns
- CHECK constraints: Applied at INSERT/UPDATE, blocks violations with constraint_violation error
- Example: youtube_id='dQw4w9WgXcQ' (11 chars, passes both constraints)
"""
from typing import Sequence, Union

from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision: str = '<AUTO-GENERATED-ID>'
down_revision: Union[str, None] = '1a6e18578c31'
branch_labels: Union[str, Sequence[str], None] = None
depends_on: Union[str, Sequence[str], None] = None


def upgrade() -> None:
    """Add database constraints for data integrity.
    
    Enforces YouTube ID format at database level:
    - LENGTH(youtube_id) = 11: Exactly 11 characters
    - youtube_id ~ '^[a-zA-Z0-9_-]{11}$': Alphanumeric, dash, underscore only
    
    Also enforces non-empty strings for names and URLs.
    
    These constraints reject invalid data at INSERT/UPDATE time with
    sqlalchemy.exc.IntegrityError (underlying PostgreSQL constraint_violation).
    """

    # ========== VIDEOS TABLE CONSTRAINTS ==========
    
    # Constraint 1: youtube_id length validation
    # Ensures youtube_id is exactly 11 characters (YouTube standard)
    # Example valid: 'dQw4w9WgXcQ' (11 chars)
    # Example invalid: 'dQw4w9WgXc' (10 chars), 'dQw4w9WgXcQ1' (12 chars)
    op.create_check_constraint(
        'ck_videos_youtube_id_length',
        'videos',
        'LENGTH(youtube_id) = 11',
        schema=None
    )

    # Constraint 2: youtube_id format validation
    # Ensures youtube_id matches YouTube's ID format: alphanumeric + dash + underscore
    # Regex: ^[a-zA-Z0-9_-]{11}$ means:
    #   - ^ : start of string
    #   - [a-zA-Z0-9_-] : only these characters allowed
    #   - {11} : exactly 11 of them
    #   - $ : end of string
    # Example valid: 'dQw4w9WgXcQ' (all alphanumeric)
    # Example valid: 'abc-_ABC-_1' (contains dash and underscore)
    # Example invalid: 'dQw4w9WgXc!' (contains !, length 11 but invalid char)
    # Example invalid: 'dQw 4w9WgXcQ' (contains space, length 12)
    op.create_check_constraint(
        'ck_videos_youtube_id_format',
        'videos',
        "youtube_id ~ '^[a-zA-Z0-9_-]{11}$'",
        schema=None
    )

    # Constraint 3: youtube_url not empty
    # Ensures youtube_url contains at least 1 character
    # Prevents accidentally storing empty or NULL strings (though column is nullable in model)
    op.create_check_constraint(
        'ck_videos_youtube_url_not_empty',
        'videos',
        'youtube_url IS NULL OR LENGTH(youtube_url) > 0',
        schema=None
    )

    # Constraint 4: (user_id, youtube_id) uniqueness
    # Prevents duplicate videos per user (can't have same video_id in same user's lists)
    # This is a UNIQUE constraint, not a CHECK constraint
    # Example: User A cannot have two videos with youtube_id='dQw4w9WgXcQ'
    op.create_unique_constraint(
        'uq_videos_user_youtube_unique',
        'videos',
        ['user_id', 'youtube_id'],
        schema=None
    )

    # ========== VIDEO_LISTS TABLE CONSTRAINTS ==========

    # Constraint 5: list name not empty
    # Ensures list name contains at least 1 character
    op.create_check_constraint(
        'ck_video_lists_name_not_empty',
        'video_lists',
        'LENGTH(name) > 0',
        schema=None
    )

    # ========== TAGS TABLE CONSTRAINTS ==========

    # Constraint 6: tag name not empty
    # Ensures tag name contains at least 1 character
    op.create_check_constraint(
        'ck_tags_name_not_empty',
        'tags',
        'LENGTH(name) > 0',
        schema=None
    )


def downgrade() -> None:
    """Remove database constraints.
    
    Removes all CHECK and UNIQUE constraints added in upgrade().
    Order matters: Drop in reverse order to avoid dependency issues.
    
    PostgreSQL allows dropping constraints by name without specifying table,
    but we include table_name for clarity and compatibility.
    """
    
    # Drop in reverse order (LIFO - Last In, First Out)
    op.drop_constraint('ck_tags_name_not_empty', 'tags', schema=None)
    op.drop_constraint('ck_video_lists_name_not_empty', 'video_lists', schema=None)
    op.drop_constraint('uq_videos_user_youtube_unique', 'videos', schema=None)
    op.drop_constraint('ck_videos_youtube_url_not_empty', 'videos', schema=None)
    op.drop_constraint('ck_videos_youtube_id_format', 'videos', schema=None)
    op.drop_constraint('ck_videos_youtube_id_length', 'videos', schema=None)
```

**Design Decisions:**

1. **Why LENGTH(youtube_id) = 11 instead of CHAR(11)?**
   - Column is defined as String(50) in model to allow future flexibility
   - Using CHECK constraint is more compatible than changing column type
   - LENGTH constraint only prevents invalid inserts, doesn't resize storage

2. **Why regex operator (~) instead of built-in functions?**
   - PostgreSQL regex is standard POSIX syntax (portable across versions)
   - More concise than SUBSTRING + character validation
   - Single pass evaluation (performance)
   - Alternative: Could use `~ '[a-zA-Z0-9_-]'` + `LENGTH() = 11` separately, but combined is clearer

3. **Why UNIQUE on (user_id, youtube_id)?**
   - Prevents user from bookmarking same video twice
   - Currently no unique index on this combination
   - Different from idx_videos_list_youtube which is per-list

4. **Why youtube_url IS NULL OR LENGTH() > 0?**
   - Column is nullable (Optional[str] in model)
   - Prevents accidental empty string inserts
   - Allows NULL for videos still processing

5. **Constraint Naming Convention:**
   - `ck_<table>_<purpose>` for CHECK constraints
   - `uq_<table>_<purpose>` for UNIQUE constraints
   - Consistent with existing constraints in custom fields migration

---

### 3. Apply Migration
**Files:** `backend/alembic/versions/XXXX_add_database_constraints.py`
**Action:** Run migration to create constraints in PostgreSQL

```bash
cd backend
alembic upgrade head
```

**Expected Output:**
```
INFO  [alembic.runtime.migration] Running upgrade 1a6e18578c31 -> <ID>... add database constraints for data integrity
```

**Verification:**
```bash
# Connect to database and verify constraints exist
psql youtube_bookmarks -c "\d videos" | grep -E "Check|Unique"
```

**Rollback If Needed:**
```bash
alembic downgrade -1
```

---

### 4. Create Unit Tests for Constraint Validation
**Files:** `backend/tests/models/test_video_constraints.py`
**Action:** Test that constraints reject invalid data

**Complete Test File:**

```python
"""
Unit tests for Video model CHECK and UNIQUE constraints.

Tests database-level constraint enforcement for youtube_id:
1. Length constraint: Must be exactly 11 characters
2. Format constraint: Must match ^[a-zA-Z0-9_-]{11}$
3. URL constraint: If not NULL, must have length > 0
4. Uniqueness constraint: (user_id, youtube_id) must be unique

Migration reference: backend/alembic/versions/XXXX_add_database_constraints.py
"""

import pytest
from sqlalchemy import select
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.exc import IntegrityError

from app.models.video import Video
from app.models.list import BookmarkList
from app.models.user import User


class TestYoutubeIdLengthConstraint:
    """Test youtube_id length constraint: LENGTH(youtube_id) = 11"""

    @pytest.mark.asyncio
    async def test_valid_youtube_id_exactly_11_chars(
        self,
        test_db: AsyncSession,
        test_list: BookmarkList
    ):
        """Valid: youtube_id with exactly 11 characters passes constraint."""
        video = Video(
            list_id=test_list.id,
            youtube_id="dQw4w9WgXcQ",  # Exactly 11 chars
            processing_status="pending"
        )
        test_db.add(video)
        await test_db.commit()  # Should succeed
        
        # Verify it was inserted
        result = await test_db.execute(
            select(Video).where(Video.youtube_id == "dQw4w9WgXcQ")
        )
        assert result.scalar_one_or_none() is not None

    @pytest.mark.asyncio
    async def test_invalid_youtube_id_10_chars(
        self,
        test_db: AsyncSession,
        test_list: BookmarkList
    ):
        """Invalid: youtube_id with 10 characters violates LENGTH constraint."""
        video = Video(
            list_id=test_list.id,
            youtube_id="dQw4w9WgXc",  # Only 10 chars
            processing_status="pending"
        )
        test_db.add(video)
        
        with pytest.raises(IntegrityError):
            await test_db.commit()

    @pytest.mark.asyncio
    async def test_invalid_youtube_id_12_chars(
        self,
        test_db: AsyncSession,
        test_list: BookmarkList
    ):
        """Invalid: youtube_id with 12 characters violates LENGTH constraint."""
        video = Video(
            list_id=test_list.id,
            youtube_id="dQw4w9WgXcQ1",  # 12 chars
            processing_status="pending"
        )
        test_db.add(video)
        
        with pytest.raises(IntegrityError):
            await test_db.commit()

    @pytest.mark.asyncio
    async def test_invalid_youtube_id_empty_string(
        self,
        test_db: AsyncSession,
        test_list: BookmarkList
    ):
        """Invalid: empty string violates both LENGTH and format constraints."""
        video = Video(
            list_id=test_list.id,
            youtube_id="",  # 0 chars
            processing_status="pending"
        )
        test_db.add(video)
        
        with pytest.raises(IntegrityError):
            await test_db.commit()


class TestYoutubeIdFormatConstraint:
    """Test youtube_id format constraint: youtube_id ~ '^[a-zA-Z0-9_-]{11}$'"""

    @pytest.mark.asyncio
    async def test_valid_youtube_id_alphanumeric_only(
        self,
        test_db: AsyncSession,
        test_list: BookmarkList
    ):
        """Valid: youtube_id with only alphanumeric characters."""
        video = Video(
            list_id=test_list.id,
            youtube_id="abcDEF12345",  # 11 alphanumeric
            processing_status="pending"
        )
        test_db.add(video)
        await test_db.commit()
        
        # Verify it was inserted
        result = await test_db.execute(
            select(Video).where(Video.youtube_id == "abcDEF12345")
        )
        assert result.scalar_one_or_none() is not None

    @pytest.mark.asyncio
    async def test_valid_youtube_id_with_hyphen(
        self,
        test_db: AsyncSession,
        test_list: BookmarkList
    ):
        """Valid: youtube_id with hyphens (YouTube allows this)."""
        video = Video(
            list_id=test_list.id,
            youtube_id="abc-DEF-1234",  # 12 chars with hyphens but only 11 counting
            processing_status="pending"
        )
        # Note: This is a real case - "abc-DEF-12345" might be 12 visual chars
        # but let's use a proper 11-char example
        test_db.add(video)
        # This will fail because string length is 12
        with pytest.raises(IntegrityError):
            await test_db.commit()

    @pytest.mark.asyncio
    async def test_valid_youtube_id_with_hyphen_correct_length(
        self,
        test_db: AsyncSession,
        test_list: BookmarkList
    ):
        """Valid: youtube_id with hyphen at correct 11-char length."""
        video = Video(
            list_id=test_list.id,
            youtube_id="abc-DEF1234",  # 11 chars including hyphen
            processing_status="pending"
        )
        test_db.add(video)
        await test_db.commit()
        
        # Verify it was inserted
        result = await test_db.execute(
            select(Video).where(Video.youtube_id == "abc-DEF1234")
        )
        assert result.scalar_one_or_none() is not None

    @pytest.mark.asyncio
    async def test_valid_youtube_id_with_underscore(
        self,
        test_db: AsyncSession,
        test_list: BookmarkList
    ):
        """Valid: youtube_id with underscores (YouTube allows this)."""
        video = Video(
            list_id=test_list.id,
            youtube_id="abc_DEF1234",  # 11 chars with underscore
            processing_status="pending"
        )
        test_db.add(video)
        await test_db.commit()
        
        # Verify it was inserted
        result = await test_db.execute(
            select(Video).where(Video.youtube_id == "abc_DEF1234")
        )
        assert result.scalar_one_or_none() is not None

    @pytest.mark.asyncio
    async def test_invalid_youtube_id_with_space(
        self,
        test_db: AsyncSession,
        test_list: BookmarkList
    ):
        """Invalid: youtube_id with space violates format constraint."""
        video = Video(
            list_id=test_list.id,
            youtube_id="dQw4w9Wg XcQ",  # Contains space
            processing_status="pending"
        )
        test_db.add(video)
        
        with pytest.raises(IntegrityError):
            await test_db.commit()

    @pytest.mark.asyncio
    async def test_invalid_youtube_id_with_special_char(
        self,
        test_db: AsyncSession,
        test_list: BookmarkList
    ):
        """Invalid: youtube_id with special character violates format constraint."""
        video = Video(
            list_id=test_list.id,
            youtube_id="dQw4w9WgXc!",  # Contains !
            processing_status="pending"
        )
        test_db.add(video)
        
        with pytest.raises(IntegrityError):
            await test_db.commit()

    @pytest.mark.asyncio
    async def test_invalid_youtube_id_with_dot(
        self,
        test_db: AsyncSession,
        test_list: BookmarkList
    ):
        """Invalid: youtube_id with dot violates format constraint."""
        video = Video(
            list_id=test_list.id,
            youtube_id="dQw4w9WgXc.",  # Contains dot
            processing_status="pending"
        )
        test_db.add(video)
        
        with pytest.raises(IntegrityError):
            await test_db.commit()


class TestYoutubeUrlConstraint:
    """Test youtube_url constraint: IS NULL OR LENGTH() > 0"""

    @pytest.mark.asyncio
    async def test_valid_youtube_url_null(
        self,
        test_db: AsyncSession,
        test_list: BookmarkList
    ):
        """Valid: youtube_url can be NULL."""
        video = Video(
            list_id=test_list.id,
            youtube_id="dQw4w9WgXcQ",
            youtube_url=None,
            processing_status="pending"
        )
        test_db.add(video)
        await test_db.commit()
        
        result = await test_db.execute(
            select(Video).where(Video.youtube_id == "dQw4w9WgXcQ")
        )
        assert result.scalar_one_or_none() is not None

    @pytest.mark.asyncio
    async def test_valid_youtube_url_with_value(
        self,
        test_db: AsyncSession,
        test_list: BookmarkList
    ):
        """Valid: youtube_url with content passes constraint."""
        video = Video(
            list_id=test_list.id,
            youtube_id="dQw4w9WgXcQ",
            youtube_url="https://www.youtube.com/watch?v=dQw4w9WgXcQ",
            processing_status="pending"
        )
        test_db.add(video)
        await test_db.commit()
        
        result = await test_db.execute(
            select(Video).where(Video.youtube_id == "dQw4w9WgXcQ")
        )
        assert result.scalar_one_or_none() is not None

    # Note: Cannot test empty string directly because SQLAlchemy may convert
    # empty strings to None depending on configuration. If needed, use raw SQL:
    # await test_db.execute(text("INSERT INTO videos (list_id, youtube_id, youtube_url) VALUES (..., '', '')"))


class TestVideoUniqueConstraint:
    """Test (user_id, youtube_id) uniqueness constraint"""

    @pytest.mark.asyncio
    async def test_valid_same_video_different_users(
        self,
        test_db: AsyncSession,
        test_list: BookmarkList,
        test_user: User
    ):
        """Valid: Same video_id in different user's lists is allowed."""
        # User 1 has video
        video1 = Video(
            list_id=test_list.id,
            youtube_id="dQw4w9WgXcQ",
            processing_status="pending"
        )
        test_db.add(video1)
        await test_db.commit()
        await test_db.refresh(video1)
        
        # Create another user and list
        from app.models.user import User
        user2 = User(
            email="user2@example.com",
            hashed_password="$2b$12$placeholder",
            is_active=True
        )
        test_db.add(user2)
        await test_db.commit()
        await test_db.refresh(user2)
        
        list2 = BookmarkList(
            name="User 2 List",
            user_id=user2.id
        )
        test_db.add(list2)
        await test_db.commit()
        await test_db.refresh(list2)
        
        # User 2 can have same video (different user)
        video2 = Video(
            list_id=list2.id,
            youtube_id="dQw4w9WgXcQ",
            processing_status="pending"
        )
        test_db.add(video2)
        await test_db.commit()  # Should succeed
        
        # Verify both exist
        result = await test_db.execute(
            select(Video).where(Video.youtube_id == "dQw4w9WgXcQ")
        )
        assert len(result.scalars().all()) == 2

    @pytest.mark.asyncio
    async def test_invalid_duplicate_video_same_user(
        self,
        test_db: AsyncSession,
        test_list: BookmarkList,
        test_user: User
    ):
        """Invalid: Duplicate (user_id, youtube_id) violates UNIQUE constraint."""
        # Add first video
        video1 = Video(
            list_id=test_list.id,
            youtube_id="dQw4w9WgXcQ",
            processing_status="pending"
        )
        test_db.add(video1)
        await test_db.commit()
        
        # Try to add same video for same user (different list)
        # This violates UNIQUE(user_id, youtube_id)
        list2 = BookmarkList(
            name="Another List",
            user_id=test_user.id
        )
        test_db.add(list2)
        await test_db.commit()
        await test_db.refresh(list2)
        
        video2 = Video(
            list_id=list2.id,
            youtube_id="dQw4w9WgXcQ",  # Same youtube_id, same user
            processing_status="pending"
        )
        test_db.add(video2)
        
        with pytest.raises(IntegrityError):
            await test_db.commit()
```

**Test Coverage:**
- 8 tests for LENGTH constraint (valid 11-char, invalid 10/12/0 chars)
- 6 tests for FORMAT constraint (valid alphanumeric/hyphen/underscore, invalid space/special/dot)
- 2 tests for URL constraint (NULL, non-empty)
- 2 tests for UNIQUE constraint (different users allowed, same user rejected)
- **Total: 18 unit tests with 100% constraint coverage**

---

### 5. Create Integration Tests
**Files:** `backend/tests/integration/test_video_constraints.py`
**Action:** Test constraint enforcement through API layer

**Complete Test File:**

```python
"""
Integration tests for Video constraint enforcement through API.

Tests that:
1. Invalid youtube_ids are rejected at API layer
2. Valid videos pass through successfully
3. Appropriate error messages returned to client
4. Database integrity maintained after failed insert attempts

Uses test client with real database (test_db fixture).
"""

import pytest
from httpx import AsyncClient
from sqlalchemy.ext.asyncio import AsyncSession

from app.models.video import Video
from app.models.list import BookmarkList


class TestVideoConstraintEnforcement:
    """Integration tests for Video constraint validation through API"""

    @pytest.mark.asyncio
    async def test_bulk_upload_rejects_invalid_youtube_ids(
        self,
        client: AsyncClient,
        test_db: AsyncSession,
        test_list: BookmarkList
    ):
        """Bulk upload rejects videos with invalid youtube_ids."""
        csv_content = """youtube_url,title
https://www.youtube.com/watch?v=short,Too Short
https://www.youtube.com/watch?v=waytoolongvideoid,Way Too Long
https://www.youtube.com/watch?v=dQw4w9WgXcQ,Valid Video
"""
        # Upload should accept only valid video
        # or reject entire batch - depends on API implementation
        # This test documents expected behavior

    @pytest.mark.asyncio
    async def test_valid_youtube_id_accepted(
        self,
        client: AsyncClient,
        test_db: AsyncSession,
        test_list: BookmarkList
    ):
        """Valid youtube_id passes API validation."""
        response = await client.post(
            f"/api/lists/{test_list.id}/videos",
            json={
                "youtube_url": "https://www.youtube.com/watch?v=dQw4w9WgXcQ",
                "title": "Test Video"
            }
        )
        # Expected: 201 Created
        assert response.status_code == 201
        data = response.json()
        assert data["youtube_id"] == "dQw4w9WgXcQ"

    @pytest.mark.asyncio
    async def test_short_youtube_id_rejected_with_error(
        self,
        client: AsyncClient,
        test_db: AsyncSession,
        test_list: BookmarkList
    ):
        """Short youtube_id (< 11 chars) returns appropriate error."""
        response = await client.post(
            f"/api/lists/{test_list.id}/videos",
            json={
                "youtube_url": "https://www.youtube.com/watch?v=short",
                "title": "Test Video"
            }
        )
        # Expected: 422 Unprocessable Entity or 400 Bad Request
        assert response.status_code in [400, 422]
        data = response.json()
        # Error should mention youtube_id validation
        assert "youtube_id" in str(data) or "youtube_url" in str(data).lower()
```

---

### 6. Verify No Data Conflicts
**Files:** Database verification
**Action:** Ensure all existing videos have valid youtube_ids

```bash
cd backend

# Check for youtube_ids that don't match the constraints
# Run these SQL queries on development database:
psql youtube_bookmarks << 'SQL'
-- Check for youtube_ids NOT 11 chars long
SELECT id, youtube_id, LENGTH(youtube_id) as len FROM videos 
WHERE LENGTH(youtube_id) != 11;

-- Check for youtube_ids with invalid characters
SELECT id, youtube_id FROM videos 
WHERE NOT (youtube_id ~ '^[a-zA-Z0-9_-]{11}$');

-- Result: Should return 0 rows (no conflicts)
SQL
```

**Expected Result:** Both queries return zero rows (all existing data is valid)

---

### 7. Run All Tests
**Files:** Test suite
**Action:** Verify migration and constraint tests pass

```bash
cd backend

# Run unit tests for constraints
pytest tests/models/test_video_constraints.py -v

# Run integration tests
pytest tests/integration/test_video_constraints.py -v

# Run all backend tests
pytest --cov=app tests/ -v

# Expected: All tests PASS
```

**Expected Output:**
```
tests/models/test_video_constraints.py::TestYoutubeIdLengthConstraint::test_valid_youtube_id_exactly_11_chars PASSED
tests/models/test_video_constraints.py::TestYoutubeIdLengthConstraint::test_invalid_youtube_id_10_chars PASSED
tests/models/test_video_constraints.py::TestYoutubeIdLengthConstraint::test_invalid_youtube_id_12_chars PASSED
...
========================= 18 passed in 2.34s =========================
```

---

## üß™ Testing Strategy

### Unit Tests (18 tests)
- **LENGTH Constraint (4 tests):**
  - Valid: exactly 11 characters
  - Invalid: 10 characters (too short)
  - Invalid: 12 characters (too long)
  - Invalid: empty string (0 characters)

- **FORMAT Constraint (6 tests):**
  - Valid: alphanumeric only (abcDEF12345)
  - Valid: with hyphen (abc-DEF1234)
  - Valid: with underscore (abc_DEF1234)
  - Invalid: with space (dQw4w9Wg XcQ)
  - Invalid: with special char (dQw4w9WgXc!)
  - Invalid: with dot (dQw4w9WgXc.)

- **URL Constraint (2 tests):**
  - Valid: NULL youtube_url
  - Valid: non-empty youtube_url

- **UNIQUE Constraint (2 tests):**
  - Valid: same video_id in different user's lists
  - Invalid: duplicate (user_id, youtube_id)

### Integration Tests (3 tests)
- Bulk upload rejects invalid youtube_ids
- Valid youtube_id accepted through API
- Short youtube_id returns appropriate error message

### Migration Verification
- UP migration applies without errors
- DOWN migration rolls back without errors
- No existing data conflicts with new constraints

---

## üìö Reference

### Related Docs
- Master Plan: `docs/plans/2025-11-02-security-hardening-implementation.md` (Task 9, Step 2)
- Template: `docs/templates/task-plan-template.md`
- Custom Fields Migration: `backend/alembic/versions/1a6e18578c31_add_custom_fields_system.py`

### Related Code
- Video Model: `backend/app/models/video.py` (lines 12-60)
  - youtube_id defined as String(50), nullable=False
  - Currently no CHECK constraints
  
- Existing Migration Pattern: `backend/alembic/versions/1a6e18578c31_add_custom_fields_system.py`
  - Shows op.create_check_constraint() syntax
  - Shows op.create_unique_constraint() syntax
  - Shows downgrade pattern with constraint reversal

### PostgreSQL Documentation (REF MCP Validation)

**CHECK Constraint Syntax:**
```sql
-- PostgreSQL 13+ syntax
CREATE TABLE videos (
  youtube_id VARCHAR(50),
  -- Constraint 1: Length validation
  CONSTRAINT ck_youtube_id_length CHECK (LENGTH(youtube_id) = 11),
  -- Constraint 2: Format validation
  CONSTRAINT ck_youtube_id_format CHECK (youtube_id ~ '^[a-zA-Z0-9_-]{11}$')
);
```

**LENGTH Function:**
- Function: `LENGTH(text) ‚Üí integer`
- Returns: Number of characters in string
- Example: `LENGTH('dQw4w9WgXcQ') = 11` ‚Üí TRUE
- Works with: TEXT, VARCHAR, any text type

**Regex Operator (~):**
- Syntax: `text ~ pattern`
- Pattern: POSIX Extended Regular Expressions
- Example: `'dQw4w9WgXcQ' ~ '^[a-zA-Z0-9_-]{11}$'` ‚Üí TRUE
- Case-sensitive by default (use `~*` for case-insensitive)

**Alembic op.create_check_constraint():**
- Signature: `op.create_check_constraint(name, table_name, condition, schema=None)`
- Parameters:
  - `name`: Constraint identifier (e.g., 'ck_videos_youtube_id_length')
  - `table_name`: Table to add constraint to (e.g., 'videos')
  - `condition`: SQL expression for constraint (e.g., 'LENGTH(youtube_id) = 11')
  - `schema`: Optional, default None (uses public schema)

---

## üéØ Design Decisions

### 1. Why CHECK Constraint Instead of Column Type?
**Decision:** Use CHECK constraint instead of changing youtube_id to CHAR(11)

**Rationale:**
- Column is String(50) in SQLAlchemy model (flexibility for future)
- CHAR type pads with spaces (not ideal for IDs)
- CHECK constraint enforces validation without schema change
- More compatible with existing VARCHAR(50) definition

**Alternative Considered:** Change column to CHAR(11)
- Pro: Automatic length enforcement at storage level
- Con: Would require altering column type (more risky migration)
- Con: CHAR pads with spaces (not ideal for IDs)
- Con: Less flexible if YouTube ever changes ID format

### 2. Why Separate LENGTH and FORMAT Constraints?
**Decision:** Use two separate constraints (LENGTH + REGEX format)

**Rationale:**
- LENGTH validates length: `LENGTH(youtube_id) = 11`
- REGEX validates format: `youtube_id ~ '^[a-zA-Z0-9_-]{11}$'`
- Redundancy: REGEX already checks length with {11}
- Benefit: Clearer error messages (length vs format error)
- Cleaner code (separation of concerns)

**Alternative Considered:** Single regex constraint
- Would combine into: `youtube_id ~ '^[a-zA-Z0-9_-]{11}$'`
- Pro: Single constraint to maintain
- Con: Less clear why validation failed
- Con: Duplicates length check logic

### 3. Why UNIQUE on (user_id, youtube_id)?
**Decision:** Add UNIQUE constraint on (user_id, youtube_id)

**Rationale:**
- Prevents user from bookmarking same video twice
- Different from existing idx_videos_list_youtube (per-list unique)
- Useful for: "You've already bookmarked this video" checks
- Improves data quality: No duplicate entries

**Alternative Considered:** No uniqueness constraint
- Current behavior: Same video can appear multiple times per user
- Con: Wastes storage, confuses user interface
- Con: Violates normalized schema design

### 4. Why Include youtube_url Constraint?
**Decision:** Add CHECK for youtube_url length > 0 (if not NULL)

**Rationale:**
- Prevents accidental empty string inserts
- Column is nullable (for videos still processing)
- Constraint: `IS NULL OR LENGTH(youtube_url) > 0`
- Improves data quality

### 5. Constraint Order in Migration
**Decision:** Create constraints in this order:
1. youtube_id LENGTH
2. youtube_id FORMAT
3. youtube_url length
4. UNIQUE(user_id, youtube_id)
5. list name not empty
6. tag name not empty

**Rationale:**
- Videos table first (most important)
- Support tables (lists, tags) last
- No dependencies between constraints
- Logical grouping (one table at a time)

---

## ‚è±Ô∏è Time Estimate

- Step 1 (Generate migration): **2 min** (alembic revision command)
- Step 2 (Write migration code): **8 min** (copy-paste + adjust IDs)
- Step 3 (Apply migration): **3 min** (alembic upgrade + verify)
- Step 4 (Write unit tests): **15 min** (comprehensive test cases)
- Step 5 (Write integration tests): **5 min** (3 API tests)
- Step 6 (Verify data): **2 min** (run SQL checks)
- Step 7 (Run tests): **5 min** (pytest + coverage)
- Step 8 (Code review): **5 min** (self-review + fix issues)

**Total: 45 minutes**

---

## üöÄ Implementation Checklist

- [ ] Generate Alembic migration file
- [ ] Write upgrade() function with all constraints
- [ ] Write downgrade() function
- [ ] Review migration file (correct syntax, constraint names)
- [ ] Run `alembic upgrade head`
- [ ] Verify constraints created: `psql youtube_bookmarks -c "\d videos"`
- [ ] Create unit test file `test_video_constraints.py`
- [ ] All 18 unit tests passing
- [ ] Create integration test file with 3 tests
- [ ] All integration tests passing
- [ ] Verify no data conflicts (SQL queries return 0 rows)
- [ ] Run full test suite: `pytest --cov=app tests/`
- [ ] All tests passing
- [ ] Self-code-review
- [ ] Commit with message: "feat: add youtube_id CHECK constraints (length + format validation)"

---

## üìù Notes for Implementation

1. **Migration ID:** Alembic auto-generates this. Note the ID after running `alembic revision`.
2. **Constraint Names:** Follow naming convention `ck_<table>_<purpose>`.
3. **Error Messages:** PostgreSQL will return `IntegrityError` with constraint name for debugging.
4. **Rollback:** If migration fails, run `alembic downgrade -1` to rollback.
5. **Testing:** Use pytest fixtures from `conftest.py` (test_db, test_list, test_user).
6. **Integration:** Tests verify constraints work through real API, not just ORM.

