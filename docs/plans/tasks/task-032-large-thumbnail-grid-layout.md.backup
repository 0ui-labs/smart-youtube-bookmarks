# Task #32: Create Large Thumbnail Grid Layout

**Plan Task:** #32
**Wave/Phase:** Wave 2 UI Cleanup - Enhanced UX
**Dependencies:** Task #31 (Thumbnail Size CSS Classes), Task #25 (Table Settings Store), Task #26 (TableSettingsDropdown)

---

## üéØ Ziel

Implementiere eine alternative Grid-Ansicht mit einem **manuellen List/Grid Toggle Button**. User kann zwischen Table-Ansicht (Liste) und Grid-Ansicht unabh√§ngig von der Thumbnail-Gr√∂√üe wechseln. Die Grid-Ansicht zeigt Video-Cards in einem responsiven Grid-Layout (2-4 Spalten) mit Hover-Effekten und optimierter Metadaten-Darstellung.

**Erwartetes Ergebnis:**
- **List/Grid Toggle Button** im Header (neben Settings Dropdown)
- User klickt Toggle ‚Üí View wechselt zwischen Table und Grid (unabh√§ngig von Thumbnail-Gr√∂√üe)
- Grid zeigt 2-4 Spalten je nach Viewport-Breite (responsive)
- Video-Cards zeigen Thumbnails (Gr√∂√üe abh√§ngig von thumbnailSize Setting), Titel, Channel, Duration, Tags
- Hover-Effekte und Clickable Cards (wie Table Rows)
- Lazy Loading mit native `loading="lazy"` (bereits implementiert)

---

## üìã Acceptance Criteria

- [ ] **ViewMode State in Store:** `tableSettingsStore` hat `viewMode: 'list' | 'grid'` mit localStorage persistence
- [ ] **List/Grid Toggle Button:** Toggle Button im Header (LayoutList/LayoutGrid Icons von lucide-react)
- [ ] **Manual View Switch:** User klickt Toggle ‚Üí View wechselt zwischen Table (list) und Grid (grid)
- [ ] **Responsive Grid:** 2 Spalten (mobile), 3 Spalten (tablet), 4 Spalten (desktop) - Tailwind Breakpoints
- [ ] **VideoCard Component:** Zeigt Thumbnail (size dynamisch via thumbnailSize), Title, Channel, Duration, Tags mit Hover-Effekten
- [ ] **Clickable Cards:** Entire card clickable (√∂ffnet Video), Three-Dot Menu stopPropagation wie Table Rows
- [ ] **Lazy Loading:** Images lazy-loaded mit native `loading="lazy"` (bereits in VideoThumbnail)
- [ ] **Tests Passing:** 12+ Unit Tests f√ºr ViewMode State, Toggle Button, VideoCard, Grid Layout, Conditional Rendering
- [ ] **Code Reviewed:** Subagent review + Semgrep + CodeRabbit (0 Critical issues)
- [ ] **TypeScript Strict:** 0 new TypeScript errors
- [ ] **Manual Testing:** Toggle funktioniert, Grid responsive, Hover-States, Clickable Cards, thumbnailSize Settings funktionieren in beiden Views

---

## üõ†Ô∏è Implementation Steps

### REF MCP Validation Results

**‚úÖ Pattern 1: Tailwind Responsive Grid (Official Docs)**
- Use `grid-cols-2 md:grid-cols-3 lg:grid-cols-4` for responsive columns
- Standard Tailwind breakpoints: `sm: 640px`, `md: 768px`, `lg: 1024px`, `xl: 1280px`
- `gap-4` oder `gap-6` f√ºr spacing zwischen cards

**‚úÖ Pattern 2: Native Lazy Loading (Modern Browser Support)**
- HTML `<img loading="lazy">` ist bereits implementiert in VideoThumbnail
- Intersection Observer NICHT n√∂tig f√ºr einfaches Image Lazy Loading
- Browser-native lazy loading hat ~97% support (caniuse.com)

**‚úÖ Pattern 3: Card Component Best Practices**
- Hover-Effekte mit Tailwind: `hover:shadow-lg transition-shadow duration-200`
- Clickable Card: `cursor-pointer` + `onClick` + `role="button"` + keyboard support
- Three-Dot Menu: `stopPropagation` auf Trigger UND MenuItems (defense-in-depth)

**‚úÖ Pattern 4: View Mode Toggle (List/Grid)**
- **Decision:** Manual Toggle Button mit `viewMode` State im tableSettingsStore
- **Why:** User control √ºber Layout-Ansicht (unabh√§ngig von Thumbnail-Gr√∂√üe)
- **Icons:** lucide-react `LayoutList` (Table view) und `LayoutGrid` (Grid view)
- **State:** `viewMode: 'list' | 'grid'` mit localStorage persistence (wie thumbnailSize)

**‚ö†Ô∏è Pattern 5: PurgeCSS Compatibility**
- KRITISCH: Alle Tailwind Classes m√ºssen vollst√§ndig im Code stehen (kein Template String Interpolation)
- Grid columns: `grid-cols-2`, `md:grid-cols-3`, `lg:grid-cols-4` - alle explizit verwenden
- Siehe Task #31 REF MCP Improvement #3 f√ºr Details

**üí° Pattern 6: YouTube Card Design Inspiration**
- Thumbnail aspect-ratio 16:9 (500x280px f√ºr xlarge)
- Title max 2 lines mit `line-clamp-2`
- Channel name mit grauem Text (`text-muted-foreground`)
- Duration overlay auf Thumbnail (bottom-right corner)
- Tags als Chips unter Title

---

### 1. Extend TableSettingsStore with `viewMode` state (TDD)

**Files:**
- Modify: `frontend/src/stores/tableSettingsStore.ts`
- Modify: `frontend/src/stores/tableSettingsStore.test.ts`

**Step 1.1: Write failing test for viewMode**

```tsx
// frontend/src/stores/tableSettingsStore.test.ts (add to existing file)

describe('useTableSettingsStore - View Mode', () => {
  beforeEach(() => {
    // Clear localStorage
    localStorage.clear()
  })

  it('defaults to list view', () => {
    const { result } = renderHook(() => useTableSettingsStore())
    expect(result.current.viewMode).toBe('list')
  })

  it('toggles between list and grid view', () => {
    const { result } = renderHook(() => useTableSettingsStore())

    act(() => {
      result.current.setViewMode('grid')
    })

    expect(result.current.viewMode).toBe('grid')

    act(() => {
      result.current.setViewMode('list')
    })

    expect(result.current.viewMode).toBe('list')
  })

  it('persists viewMode to localStorage', () => {
    const { result } = renderHook(() => useTableSettingsStore())

    act(() => {
      result.current.setViewMode('grid')
    })

    // Unmount and remount to test persistence
    const { result: result2 } = renderHook(() => useTableSettingsStore())
    expect(result2.current.viewMode).toBe('grid')
  })
})
```

**Step 1.2: Run test to verify it fails**

```bash
cd frontend
npm test -- tableSettingsStore.test.ts
```

Expected: FAIL (viewMode not implemented)

**Step 1.3: Implement viewMode in store**

```tsx
// frontend/src/stores/tableSettingsStore.ts

/**
 * View mode for video display
 * - list: Table view with rows (default)
 * - grid: Grid view with cards (responsive columns)
 */
export type ViewMode = 'list' | 'grid';

interface TableSettingsStore {
  thumbnailSize: ThumbnailSize;
  visibleColumns: VisibleColumns;
  viewMode: ViewMode; // NEW

  setThumbnailSize: (size: ThumbnailSize) => void;
  toggleColumn: (column: keyof VisibleColumns) => void;
  setViewMode: (mode: ViewMode) => void; // NEW
}

export const useTableSettingsStore = create<TableSettingsStore>()(
  persist(
    (set) => ({
      // State
      thumbnailSize: 'small',
      visibleColumns: DEFAULT_VISIBLE_COLUMNS,
      viewMode: 'list', // NEW: Default to list view

      // Actions
      setThumbnailSize: (size) => set({ thumbnailSize: size }),
      toggleColumn: (column) =>
        set((state) => ({
          visibleColumns: {
            ...state.visibleColumns,
            [column]: !state.visibleColumns[column],
          },
        })),
      setViewMode: (mode) => set({ viewMode: mode }), // NEW
    }),
    {
      name: 'video-table-settings',
      storage: createJSONStorage(() => localStorage),
    }
  )
);
```

**Step 1.4: Run test to verify it passes**

```bash
cd frontend
npm test -- tableSettingsStore.test.ts
```

Expected: 16/16 tests PASS (13 existing + 3 new)

**Why:**
- ViewMode state separate from thumbnailSize (user control)
- localStorage persistence (setting survives page reload)
- Default 'list' maintains current behavior

---

### 2. Create ViewModeToggle Button Component (TDD)

**Files:**
- Create: `frontend/src/components/ViewModeToggle.tsx`
- Create: `frontend/src/components/ViewModeToggle.test.tsx`

**Step 2.1: Write failing test**

```tsx
// frontend/src/components/ViewModeToggle.test.tsx
import { describe, it, expect, vi } from 'vitest'
import { render, screen } from '@testing-library/react'
import userEvent from '@testing-library/user-event'
import { ViewModeToggle } from './ViewModeToggle'

describe('ViewModeToggle', () => {
  it('shows LayoutGrid icon when in list view', () => {
    render(<ViewModeToggle viewMode="list" onToggle={vi.fn()} />)

    // Should show "Switch to Grid" tooltip
    const button = screen.getByRole('button', { name: /Grid-Ansicht/i })
    expect(button).toBeInTheDocument()
  })

  it('shows LayoutList icon when in grid view', () => {
    render(<ViewModeToggle viewMode="grid" onToggle={vi.fn()} />)

    // Should show "Switch to List" tooltip
    const button = screen.getByRole('button', { name: /Listen-Ansicht/i })
    expect(button).toBeInTheDocument()
  })

  it('calls onToggle with grid when clicking from list view', async () => {
    const onToggle = vi.fn()
    render(<ViewModeToggle viewMode="list" onToggle={onToggle} />)

    await userEvent.click(screen.getByRole('button'))

    expect(onToggle).toHaveBeenCalledWith('grid')
  })

  it('calls onToggle with list when clicking from grid view', async () => {
    const onToggle = vi.fn()
    render(<ViewModeToggle viewMode="grid" onToggle={onToggle} />)

    await userEvent.click(screen.getByRole('button'))

    expect(onToggle).toHaveBeenCalledWith('list')
  })
})
```

**Step 2.2: Run test to verify it fails**

```bash
cd frontend
npm test -- ViewModeToggle.test.tsx
```

Expected: FAIL

**Step 2.3: Implement ViewModeToggle component**

```tsx
// frontend/src/components/ViewModeToggle.tsx
import { LayoutList, LayoutGrid } from 'lucide-react'
import { Button } from '@/components/ui/button'
import type { ViewMode } from '@/stores/tableSettingsStore'

interface ViewModeToggleProps {
  viewMode: ViewMode
  onToggle: (mode: ViewMode) => void
}

/**
 * ViewModeToggle - Toggle button for switching between list and grid view
 *
 * Shows opposite mode icon (Grid icon in list view, List icon in grid view)
 * to indicate what will happen when clicked (affordance pattern)
 */
export const ViewModeToggle = ({ viewMode, onToggle }: ViewModeToggleProps) => {
  const handleToggle = () => {
    onToggle(viewMode === 'list' ? 'grid' : 'list')
  }

  return (
    <Button
      variant="ghost"
      size="icon"
      onClick={handleToggle}
      aria-label={
        viewMode === 'list' ? 'Grid-Ansicht anzeigen' : 'Listen-Ansicht anzeigen'
      }
    >
      {viewMode === 'list' ? (
        <LayoutGrid className="h-4 w-4" />
      ) : (
        <LayoutList className="h-4 w-4" />
      )}
    </Button>
  )
}
```

**Step 2.4: Run tests to verify they pass**

```bash
cd frontend
npm test -- ViewModeToggle.test.tsx
```

Expected: 4/4 tests PASS

**Why:**
- Shows opposite icon (affordance: indicates what happens on click)
- Ghost variant (consistent with Plus icon and Settings dropdown)
- ARIA label for accessibility

### 3. Create VideoCard Component (TDD)

**Files:**
- Create: `frontend/src/components/VideoCard.tsx`
- Create: `frontend/src/components/VideoCard.test.tsx`

**Step 3.1: Write failing test**

```tsx
// frontend/src/components/VideoCard.test.tsx
// In Thumbnail-Gr√∂√üe section, add:

<DropdownMenuRadioGroup value={thumbnailSize} onValueChange={(value) => setThumbnailSize(value as ThumbnailSize)}>
  <DropdownMenuRadioItem value="small">Klein</DropdownMenuRadioItem>
  <DropdownMenuRadioItem value="medium">Mittel</DropdownMenuRadioItem>
  <DropdownMenuRadioItem value="large">Gro√ü</DropdownMenuRadioItem>
  <DropdownMenuRadioItem value="xlarge">Extra Gro√ü (Grid)</DropdownMenuRadioItem> {/* NEW */}
</DropdownMenuRadioGroup>
```

**Why:** User needs UI control to activate Grid view via xlarge setting

---

### 3. Create VideoCard Component (TDD)

**Files:**
- Create: `frontend/src/components/VideoCard.tsx`
- Create: `frontend/src/components/VideoCard.test.tsx`

**Step 3.1: Write failing test**

```tsx
// frontend/src/components/VideoCard.test.tsx
import { describe, it, expect, vi } from 'vitest'
import { render, screen } from '@testing-library/react'
import userEvent from '@testing-library/user-event'
import { VideoCard } from './VideoCard'
import type { VideoResponse } from '@/types/video'

const mockVideo: VideoResponse = {
  id: 'video-123',
  youtube_id: 'dQw4w9WgXcQ',
  title: 'Test Video Title That Is Very Long And Should Be Truncated',
  channel_name: 'Test Channel',
  duration: 240, // 4 minutes
  thumbnail_url: 'https://img.youtube.com/vi/dQw4w9WgXcQ/maxresdefault.jpg',
  published_at: '2025-01-01T00:00:00Z',
  tags: [
    { id: 'tag-1', name: 'Python', color: '#3B82F6' },
    { id: 'tag-2', name: 'Tutorial', color: '#10B981' },
  ],
}

describe('VideoCard', () => {
  it('renders video thumbnail with 500x280 size', () => {
    render(<VideoCard video={mockVideo} onDelete={vi.fn()} />)

    const img = screen.getByRole('img', { name: /Test Video/i })
    expect(img).toBeInTheDocument()
    expect(img).toHaveClass('w-[500px]')
  })

  it('renders video title truncated to 2 lines', () => {
    render(<VideoCard video={mockVideo} onDelete={vi.fn()} />)

    const title = screen.getByText(/Test Video Title/)
    expect(title).toBeInTheDocument()
    expect(title).toHaveClass('line-clamp-2')
  })

  it('renders channel name in muted color', () => {
    render(<VideoCard video={mockVideo} onDelete={vi.fn()} />)

    const channel = screen.getByText('Test Channel')
    expect(channel).toHaveClass('text-muted-foreground')
  })

  it('renders formatted duration', () => {
    render(<VideoCard video={mockVideo} onDelete={vi.fn()} />)

    expect(screen.getByText('4:00')).toBeInTheDocument()
  })

  it('renders tags as chips', () => {
    render(<VideoCard video={mockVideo} onDelete={vi.fn()} />)

    expect(screen.getByText('Python')).toBeInTheDocument()
    expect(screen.getByText('Tutorial')).toBeInTheDocument()
  })

  it('calls onClick when card is clicked', async () => {
    const onClick = vi.fn()
    render(<VideoCard video={mockVideo} onDelete={vi.fn()} onClick={onClick} />)

    const card = screen.getByRole('button', { name: /Test Video/i })
    await userEvent.click(card)

    expect(onClick).toHaveBeenCalledWith(mockVideo)
  })

  it('does not call onClick when three-dot menu is clicked', async () => {
    const onClick = vi.fn()
    render(<VideoCard video={mockVideo} onDelete={vi.fn()} onClick={onClick} />)

    const menuButton = screen.getByLabelText('Aktionen')
    await userEvent.click(menuButton)

    expect(onClick).not.toHaveBeenCalled()
  })

  it('shows hover effects on card hover', () => {
    render(<VideoCard video={mockVideo} onDelete={vi.fn()} />)

    const card = screen.getByRole('button', { name: /Test Video/i })
    expect(card).toHaveClass('hover:shadow-lg')
  })
})
```

**Step 3.2: Run test to verify it fails**

```bash
cd frontend
npm test -- VideoCard.test.tsx
```

Expected: FAIL (component doesn't exist yet)

**Step 3.3: Implement VideoCard component**

```tsx
// frontend/src/components/VideoCard.tsx
import { MoreVertical, Trash2 } from 'lucide-react'
import { Button } from '@/components/ui/button'
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
} from '@/components/ui/dropdown-menu'
import { formatDuration } from '@/utils/formatDuration'
import type { VideoResponse } from '@/types/video'
import { VideoThumbnail } from './VideosPage' // Reuse existing component

interface VideoCardProps {
  video: VideoResponse
  onClick?: (video: VideoResponse) => void
  onDelete: (videoId: string) => void
}

/**
 * VideoCard Component - Grid view card for large thumbnails
 *
 * REF MCP Patterns:
 * - Responsive card with hover effects (shadow-lg transition)
 * - Clickable card with keyboard support (role="button", onKeyDown)
 * - Three-dot menu with stopPropagation (defense-in-depth)
 * - Native lazy loading via VideoThumbnail (already implemented)
 * - YouTube-inspired design (16:9 thumbnail, line-clamp-2 title, tag chips)
 */
export const VideoCard = ({ video, onClick, onDelete }: VideoCardProps) => {
  const handleCardClick = () => {
    onClick?.(video)
  }

  const handleKeyDown = (e: React.KeyboardEvent) => {
    if (e.key === 'Enter' || e.key === ' ') {
      e.preventDefault()
      handleCardClick()
    }
  }

  const handleDelete = (e: React.MouseEvent) => {
    e.stopPropagation() // Prevent card click
    onDelete(video.id)
  }

  return (
    <div
      role="button"
      tabIndex={0}
      aria-label={`Video: ${video.title}`}
      onClick={handleCardClick}
      onKeyDown={handleKeyDown}
      className="video-card group cursor-pointer rounded-lg border bg-card transition-shadow duration-200 hover:shadow-lg focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2"
    >
      {/* Thumbnail Container with Duration Overlay */}
      <div className="relative">
        <VideoThumbnail url={video.thumbnail_url} title={video.title} />

        {/* Duration Overlay (bottom-right corner) */}
        {video.duration && (
          <div className="absolute bottom-2 right-2 rounded bg-black/80 px-1.5 py-0.5 text-xs font-semibold text-white">
            {formatDuration(video.duration)}
          </div>
        )}
      </div>

      {/* Card Content */}
      <div className="p-3 space-y-2">
        {/* Title (max 2 lines) */}
        <h3 className="text-sm font-semibold line-clamp-2 leading-tight">
          {video.title}
        </h3>

        {/* Channel Name */}
        {video.channel_name && (
          <p className="text-xs text-muted-foreground truncate">
            {video.channel_name}
          </p>
        )}

        {/* Tags */}
        {video.tags && video.tags.length > 0 && (
          <div className="flex flex-wrap gap-1">
            {video.tags.map((tag) => (
              <span
                key={tag.id}
                className="inline-flex items-center gap-1 rounded-full bg-secondary px-2 py-0.5 text-xs"
              >
                {tag.color && (
                  <div
                    className="h-2 w-2 rounded-full"
                    style={{ backgroundColor: tag.color }}
                  />
                )}
                <span>{tag.name}</span>
              </span>
            ))}
          </div>
        )}
      </div>

      {/* Three-Dot Menu (top-right corner) */}
      <div className="absolute top-2 right-2">
        <DropdownMenu>
          <DropdownMenuTrigger asChild onClick={(e) => e.stopPropagation()}>
            <Button
              variant="ghost"
              size="icon"
              className="h-8 w-8 bg-black/50 text-white hover:bg-black/70"
              aria-label="Aktionen"
            >
              <MoreVertical className="h-4 w-4" />
            </Button>
          </DropdownMenuTrigger>

          <DropdownMenuContent align="end" onClick={(e) => e.stopPropagation()}>
            <DropdownMenuItem onClick={handleDelete}>
              <Trash2 className="mr-2 h-4 w-4" />
              L√∂schen
            </DropdownMenuItem>
          </DropdownMenuContent>
        </DropdownMenu>
      </div>
    </div>
  )
}
```

**Step 3.4: Run tests to verify they pass**

```bash
cd frontend
npm test -- VideoCard.test.tsx
```

Expected: 8/8 tests PASS

**Why:**
- Reuses VideoThumbnail component (already has xlarge sizing + lazy loading)
- YouTube-inspired design (clean, professional)
- Hover effects for better UX
- Accessible (keyboard navigation, ARIA labels)
- Defense-in-depth stopPropagation (menu trigger AND content)

---

### 4. Create VideoGrid Component (TDD)

**Files:**
- Create: `frontend/src/components/VideoGrid.tsx`
- Create: `frontend/src/components/VideoGrid.test.tsx`

**Step 4.1: Write failing test**

```tsx
// frontend/src/components/VideoGrid.test.tsx
import { describe, it, expect, vi } from 'vitest'
import { render, screen } from '@testing-library/react'
import { VideoGrid } from './VideoGrid'
import type { VideoResponse } from '@/types/video'

const mockVideos: VideoResponse[] = [
  {
    id: 'video-1',
    youtube_id: 'video1',
    title: 'Video 1',
    channel_name: 'Channel 1',
    duration: 180,
    thumbnail_url: 'https://example.com/1.jpg',
    published_at: '2025-01-01',
    tags: [],
  },
  {
    id: 'video-2',
    youtube_id: 'video2',
    title: 'Video 2',
    channel_name: 'Channel 2',
    duration: 240,
    thumbnail_url: 'https://example.com/2.jpg',
    published_at: '2025-01-02',
    tags: [],
  },
]

describe('VideoGrid', () => {
  it('renders grid with responsive columns', () => {
    const { container } = render(
      <VideoGrid videos={mockVideos} onVideoClick={vi.fn()} onDelete={vi.fn()} />
    )

    const grid = container.querySelector('.video-grid')
    expect(grid).toHaveClass('grid')
    expect(grid).toHaveClass('grid-cols-2')
    expect(grid).toHaveClass('md:grid-cols-3')
    expect(grid).toHaveClass('lg:grid-cols-4')
  })

  it('renders VideoCard for each video', () => {
    render(<VideoGrid videos={mockVideos} onVideoClick={vi.fn()} onDelete={vi.fn()} />)

    expect(screen.getByText('Video 1')).toBeInTheDocument()
    expect(screen.getByText('Video 2')).toBeInTheDocument()
  })

  it('shows empty state when no videos', () => {
    render(<VideoGrid videos={[]} onVideoClick={vi.fn()} onDelete={vi.fn()} />)

    expect(screen.getByText(/Keine Videos gefunden/i)).toBeInTheDocument()
  })

  it('uses gap-6 for spacing between cards', () => {
    const { container } = render(
      <VideoGrid videos={mockVideos} onVideoClick={vi.fn()} onDelete={vi.fn()} />
    )

    const grid = container.querySelector('.video-grid')
    expect(grid).toHaveClass('gap-6')
  })
})
```

**Step 4.2: Run test to verify it fails**

```bash
cd frontend
npm test -- VideoGrid.test.tsx
```

Expected: FAIL

**Step 4.3: Implement VideoGrid component**

```tsx
// frontend/src/components/VideoGrid.tsx
import { VideoCard } from './VideoCard'
import type { VideoResponse } from '@/types/video'

interface VideoGridProps {
  videos: VideoResponse[]
  onVideoClick: (video: VideoResponse) => void
  onDelete: (videoId: string) => void
}

/**
 * VideoGrid Component - Responsive grid layout for video cards
 *
 * REF MCP Patterns:
 * - Tailwind responsive grid: grid-cols-2 (mobile) ‚Üí md:grid-cols-3 (tablet) ‚Üí lg:grid-cols-4 (desktop)
 * - Standard Tailwind breakpoints: sm: 640px, md: 768px, lg: 1024px, xl: 1280px
 * - gap-6 (24px) for comfortable spacing between cards
 * - Empty state with centered message when no videos
 *
 * PurgeCSS Safety:
 * - All Tailwind classes explicitly written (no template literals)
 * - grid-cols-2, md:grid-cols-3, lg:grid-cols-4 are all scanned by PurgeCSS
 */
export const VideoGrid = ({ videos, onVideoClick, onDelete }: VideoGridProps) => {
  // Empty state
  if (videos.length === 0) {
    return (
      <div className="flex flex-col items-center justify-center py-12 text-center">
        <p className="text-muted-foreground">
          Keine Videos gefunden. F√ºge Videos hinzu oder √§ndere deine Filter.
        </p>
      </div>
    )
  }

  return (
    <div className="video-grid grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-6">
      {videos.map((video) => (
        <VideoCard
          key={video.id}
          video={video}
          onClick={onVideoClick}
          onDelete={onDelete}
        />
      ))}
    </div>
  )
}
```

**Step 4.4: Run tests to verify they pass**

```bash
cd frontend
npm test -- VideoGrid.test.tsx
```

Expected: 4/4 tests PASS

**Why:**
- Responsive grid with Tailwind breakpoints (mobile-first approach)
- gap-6 (24px) provides comfortable spacing for large cards
- Empty state for better UX
- PurgeCSS-safe (all classes explicitly written)

---

### 5. Update VideosPage with Conditional Rendering

**Files:** `frontend/src/components/VideosPage.tsx`
**Action:** Add conditional rendering: Table view for small/medium/large, Grid view for xlarge

**Code:**

```tsx
// frontend/src/components/VideosPage.tsx
import { VideoGrid } from './VideoGrid' // Add import

export const VideosPage = ({ listId }: VideosPageProps) => {
  // ... existing code ...

  // Get thumbnail size from store
  const thumbnailSize = useTableSettingsStore((state) => state.thumbnailSize)

  // Determine if we should show grid view (xlarge) or table view (small/medium/large)
  const showGridView = thumbnailSize === 'xlarge'

  // ... existing handlers ...

  const handleVideoClick = (video: VideoResponse) => {
    // Open YouTube video in new tab
    window.open(`https://www.youtube.com/watch?v=${video.youtube_id}`, '_blank', 'noopener,noreferrer')
  }

  return (
    <div className="flex h-screen">
      {/* Sidebar with TagNavigation */}
      <CollapsibleSidebar>
        <TagNavigation
          tags={tags}
          selectedTagIds={selectedTagIds}
          onTagClick={toggleTag}
          onCreateTag={() => setIsCreateTagDialogOpen(true)}
        />
      </CollapsibleSidebar>

      {/* Main Content */}
      <div className="flex-1 overflow-auto p-6">
        {/* Header with Title, Plus Icon, Settings */}
        <div className="mb-6 flex items-center justify-between">
          <h1 className="text-2xl font-bold">
            {selectedTags.length > 0
              ? selectedTags.map((t) => t.name).join(', ')
              : 'Videos'}
          </h1>

          <div className="flex gap-2">
            {/* Plus Icon */}
            {FEATURE_FLAGS.SHOW_ADD_PLUS_ICON_BUTTON && (
              <Button
                variant="ghost"
                size="icon"
                onClick={() => setIsAdding(true)}
                aria-label="Video hinzuf√ºgen"
              >
                <Plus className="h-4 w-4" />
              </Button>
            )}

            {/* Settings Dropdown */}
            <TableSettingsDropdown
              onExportFiltered={handleExportFiltered}
              onExportAll={handleExportAll}
            />
          </div>
        </div>

        {/* Conditional Rendering: Grid or Table */}
        {isLoading ? (
          <p>Lade Videos...</p>
        ) : showGridView ? (
          // Grid View for xlarge thumbnails
          <VideoGrid
            videos={videos}
            onVideoClick={handleVideoClick}
            onDelete={(videoId) => {
              const video = videos.find((v) => v.id === videoId)
              if (video) {
                setDeleteModal({
                  open: true,
                  videoId: video.id,
                  videoTitle: video.title,
                })
              }
            }}
          />
        ) : (
          // Table View for small/medium/large thumbnails
          <div className="rounded-md border">
            {/* ... existing table code ... */}
          </div>
        )}

        {/* Existing Modals */}
        <ConfirmDeleteModal
          open={deleteModal.open}
          videoId={deleteModal.videoId}
          videoTitle={deleteModal.videoTitle}
          onClose={() => setDeleteModal({ open: false, videoId: null, videoTitle: null })}
          onConfirm={() => {
            if (deleteModal.videoId) {
              deleteVideo.mutate(deleteModal.videoId)
            }
            setDeleteModal({ open: false, videoId: null, videoTitle: null })
          }}
        />

        <CreateTagDialog
          open={isCreateTagDialogOpen}
          onClose={() => setIsCreateTagDialogOpen(false)}
        />
      </div>
    </div>
  )
}
```

**Why:**
- Automatic switch based on thumbnailSize (no extra state needed)
- xlarge implicitly means "Grid view with large thumbnails"
- Keeps Table view for small/medium/large (existing functionality)
- Reuses existing handlers (handleVideoClick, onDelete)

---

### 6. Add Integration Tests

**Files:** `frontend/src/components/VideosPage.integration.test.tsx`
**Action:** Add test cases for Grid view conditional rendering

**Code:**

```tsx
// frontend/src/components/VideosPage.integration.test.tsx (add to existing file)

describe('VideosPage - Grid View', () => {
  it('shows table view when thumbnailSize is small/medium/large', async () => {
    // Set thumbnail size to 'large'
    act(() => {
      useTableSettingsStore.setState({ thumbnailSize: 'large' })
    })

    renderWithRouter(<VideosPage listId={mockListId} />)

    // Wait for videos to load
    await waitFor(() => {
      expect(screen.queryByText('Lade Videos...')).not.toBeInTheDocument()
    })

    // Should show table (not grid)
    expect(screen.getByRole('table')).toBeInTheDocument()
    expect(screen.queryByTestId('video-grid')).not.toBeInTheDocument()
  })

  it('shows grid view when thumbnailSize is xlarge', async () => {
    // Set thumbnail size to 'xlarge'
    act(() => {
      useTableSettingsStore.setState({ thumbnailSize: 'xlarge' })
    })

    renderWithRouter(<VideosPage listId={mockListId} />)

    // Wait for videos to load
    await waitFor(() => {
      expect(screen.queryByText('Lade Videos...')).not.toBeInTheDocument()
    })

    // Should show grid (not table)
    expect(screen.queryByRole('table')).not.toBeInTheDocument()
    const grid = screen.getByTestId('video-grid')
    expect(grid).toBeInTheDocument()
    expect(grid).toHaveClass('grid-cols-2')
  })

  it('switches from table to grid when changing to xlarge', async () => {
    // Start with small size
    act(() => {
      useTableSettingsStore.setState({ thumbnailSize: 'small' })
    })

    renderWithRouter(<VideosPage listId={mockListId} />)

    await waitFor(() => {
      expect(screen.getByRole('table')).toBeInTheDocument()
    })

    // Change to xlarge
    act(() => {
      useTableSettingsStore.setState({ thumbnailSize: 'xlarge' })
    })

    // Should now show grid
    await waitFor(() => {
      expect(screen.queryByRole('table')).not.toBeInTheDocument()
      expect(screen.getByTestId('video-grid')).toBeInTheDocument()
    })
  })
})
```

**Expected:** 3/3 integration tests PASS

---

### 7. Manual Testing & Browser Verification

**Files:** N/A (manual testing)
**Action:** Test Grid view in browser with different viewport sizes

**Manual Testing Checklist:**

```bash
# Start dev server (if not running)
cd frontend
npm run dev
```

**Test Cases:**

1. **Grid Activation:**
   - Open http://localhost:5173
   - Open TableSettingsDropdown
   - Select "Extra Gro√ü (Grid)"
   - ‚úÖ View switches from Table to Grid
   - ‚úÖ Videos displayed in grid layout

2. **Responsive Grid:**
   - Resize browser to mobile width (~400px)
   - ‚úÖ Grid shows 2 columns
   - Resize to tablet width (~800px)
   - ‚úÖ Grid shows 3 columns
   - Resize to desktop width (~1200px)
   - ‚úÖ Grid shows 4 columns

3. **VideoCard Interactions:**
   - Hover over card
   - ‚úÖ Shadow appears (hover:shadow-lg)
   - Click on card body
   - ‚úÖ YouTube video opens in new tab
   - Click three-dot menu
   - ‚úÖ Menu opens (card click does NOT fire)
   - Click "L√∂schen"
   - ‚úÖ Delete modal appears

4. **Lazy Loading:**
   - Scroll down slowly
   - ‚úÖ Images load as they enter viewport (native lazy loading)

5. **Thumbnail Sizing:**
   - Verify thumbnails are 500px width (xlarge)
   - ‚úÖ Aspect ratio 16:9 preserved
   - ‚úÖ Duration overlay visible on bottom-right

6. **Empty State:**
   - Select tag with no videos
   - ‚úÖ "Keine Videos gefunden" message displayed

7. **Switch Back to Table:**
   - Select "Klein" / "Mittel" / "Gro√ü" size
   - ‚úÖ View switches back to Table layout

---

### 8. TypeScript Check & Code Quality

**Files:** All modified files
**Action:** Verify 0 new TypeScript errors

**Commands:**

```bash
cd frontend

# TypeScript check
npx tsc --noEmit

# Run all tests
npm test

# Lint check
npm run lint
```

**Expected:**
- TypeScript: 0 new errors (3 pre-existing documented in Handoff #31)
- Tests: All passing (VideoCard 8/8, VideoGrid 4/4, Integration 3/3 = 15/15)
- Lint: 0 errors

---

## üß™ Testing Strategy

### Unit Tests (12 tests total)

**VideoCard.test.tsx (8 tests):**
1. ‚úÖ Renders thumbnail with 500x280 size (w-[500px])
2. ‚úÖ Renders title truncated to 2 lines (line-clamp-2)
3. ‚úÖ Renders channel name in muted color (text-muted-foreground)
4. ‚úÖ Renders formatted duration (4:00)
5. ‚úÖ Renders tags as chips with color indicators
6. ‚úÖ Calls onClick when card clicked
7. ‚úÖ Does NOT call onClick when menu clicked (stopPropagation)
8. ‚úÖ Shows hover effects (hover:shadow-lg)

**VideoGrid.test.tsx (4 tests):**
1. ‚úÖ Renders responsive grid (grid-cols-2 md:grid-cols-3 lg:grid-cols-4)
2. ‚úÖ Renders VideoCard for each video
3. ‚úÖ Shows empty state when no videos
4. ‚úÖ Uses gap-6 for spacing

### Integration Tests (3 tests)

**VideosPage.integration.test.tsx:**
1. ‚úÖ Shows table view when thumbnailSize is small/medium/large
2. ‚úÖ Shows grid view when thumbnailSize is xlarge
3. ‚úÖ Switches from table to grid when changing to xlarge

### Manual Testing (7 scenarios)

1. Grid activation via dropdown
2. Responsive columns (mobile/tablet/desktop)
3. VideoCard interactions (hover, click, menu)
4. Lazy loading verification
5. Thumbnail sizing (500x280px)
6. Empty state display
7. Switch back to table view

---

## üìö Reference

### Related Docs

**Master Plan:**
- `docs/plans/2025-10-31-ID-05-ux-optimization-implementation-plan.md` - Section "Wave 2: UI Cleanup", Task 2.7 "Thumbnail Size Styling"

**External Docs:**
- [Tailwind CSS Grid Template Columns](https://tailwindcss.com/docs/grid-template-columns) - Responsive grid utilities
- [Tailwind CSS Responsive Design](https://tailwindcss.com/docs/responsive-design) - Breakpoint system
- [MDN Lazy Loading Images](https://developer.mozilla.org/en-US/docs/Web/Performance/Lazy_loading#images) - Native lazy loading

### Related Code

**Similar Patterns:**
- `frontend/src/components/VideosPage.tsx` - Lines 44-94: VideoThumbnail component (reuse for xlarge sizing)
- `frontend/src/components/VideosPage.tsx` - Lines 260-280: Table row clickable pattern (apply to VideoCard)
- `frontend/src/components/VideoTable.tsx` - Three-dot menu pattern (replicate in VideoCard)

**Dependencies:**
- `frontend/src/stores/tableSettingsStore.ts` - ThumbnailSize type includes 'xlarge'
- `frontend/src/components/TableSettingsDropdown.tsx` - RadioGroup for size selection
- `frontend/src/utils/formatDuration.ts` - Duration formatting utility

### Design Decisions

**1. Automatic Layout Switch vs Manual Toggle**

**Options:**
- A) Automatic switch when `thumbnailSize === 'xlarge'` (CHOSEN)
- B) Manual toggle button "Table / Grid" + separate size setting

**Decision:** Option A (Automatic)

**Rationale:**
- Simpler UX: One control instead of two
- xlarge thumbnails (500px) don't fit well in table layout anyway
- Grid view is natural fit for large thumbnails (YouTube pattern)
- Can add manual toggle later if users request it (non-breaking change)

**Trade-offs:**
- Pro: Fewer UI controls, clearer intent (xlarge = Grid view)
- Con: Less flexibility (can't have small thumbnails in grid)

**Validation:** User testing in MVP will determine if manual toggle is needed

---

**2. Responsive Breakpoints**

**Options:**
- A) 2 ‚Üí 3 ‚Üí 4 columns (CHOSEN)
- B) 1 ‚Üí 2 ‚Üí 3 ‚Üí 4 columns
- C) Custom breakpoints (e.g., 3 ‚Üí 4 ‚Üí 5 columns)

**Decision:** Option A (2-3-4)

**Rationale:**
- 2 columns on mobile (400-767px): Thumbnails still visible at 500px
- 3 columns on tablet (768-1023px): Comfortable spacing with gap-6
- 4 columns on desktop (1024px+): Maximum content density without crowding
- Standard Tailwind breakpoints (no custom config needed)

**Trade-offs:**
- Pro: Works across all common screen sizes
- Con: Very wide monitors (2560px+) still show only 4 columns (could add xl:grid-cols-5 later)

**REF MCP Validation:** Aligns with Tailwind best practices and YouTube's grid patterns

---

**3. VideoCard Three-Dot Menu Position**

**Options:**
- A) Top-right overlay on thumbnail (CHOSEN)
- B) Bottom-right overlay on thumbnail
- C) Below thumbnail in content area

**Decision:** Option A (Top-right overlay)

**Rationale:**
- Always visible (doesn't require hover)
- Doesn't obscure important content (duration is bottom-right)
- Consistent with mobile app patterns (action buttons on top)
- Black/50 background ensures visibility over any thumbnail

**Trade-offs:**
- Pro: Always accessible, clear visual hierarchy
- Con: Slightly overlaps thumbnail (minor visual compromise)

**Alternative Considered:** Hover-only menu (rejected for accessibility - keyboard users wouldn't see it)

---

**4. Native Lazy Loading vs Intersection Observer**

**Options:**
- A) Native `<img loading="lazy">` (CHOSEN)
- B) React Intersection Observer library
- C) Custom Intersection Observer implementation

**Decision:** Option A (Native lazy loading)

**Rationale:**
- Already implemented in VideoThumbnail component (Task #31)
- 97% browser support (caniuse.com)
- Zero JavaScript overhead (browser-native)
- Simpler code, fewer dependencies

**Trade-offs:**
- Pro: Simplest, most performant, widest support
- Con: Less control over loading threshold (but default works well)

**REF MCP Validation:** Modern browsers handle native lazy loading well, no library needed

---

**5. PurgeCSS Safety Strategy**

**Critical Pattern:** All Tailwind classes MUST be complete strings (no template literals)

**Why:**
- Tailwind's PurgeCSS scans codebase for class strings at build time
- Template literals like `` `grid-cols-${num}` `` are NOT detected
- Missing classes in production bundle = broken styles

**Implementation:**
```tsx
// ‚ùå WRONG (breaks production build):
const cols = isMobile ? 2 : 4
className={`grid-cols-${cols}`}

// ‚úÖ CORRECT (PurgeCSS-safe):
className="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4"
```

**Reference:** Task #31 REF MCP Improvement #3 - Detailed PurgeCSS analysis

---

## ‚è±Ô∏è Estimated Time

**Total:** 3-4 hours

**Breakdown:**
- REF MCP Validation: 30 min ‚úÖ (Done in planning phase)
- VideoCard Component (TDD): 60 min
- VideoGrid Component (TDD): 30 min
- VideosPage Integration: 30 min
- TableSettingsDropdown Update: 15 min
- Integration Tests: 30 min
- Manual Testing: 30 min
- Documentation & Commit: 30 min

**Complexity:** Medium
- New components (VideoCard, VideoGrid) but reuses existing patterns
- Conditional rendering is straightforward
- Most complexity in responsive grid CSS (but Tailwind makes this easy)

---

## üéØ Success Criteria

**Definition of Done:**

‚úÖ User can select "Extra Gro√ü (Grid)" in TableSettingsDropdown
‚úÖ VideosPage automatically switches from Table to Grid view
‚úÖ Grid displays 2/3/4 columns responsively
‚úÖ VideoCards show large thumbnails (500x280px), title, channel, duration, tags
‚úÖ Cards are clickable (open YouTube video)
‚úÖ Three-dot menu works with stopPropagation
‚úÖ All 15 tests passing (8 VideoCard + 4 VideoGrid + 3 Integration)
‚úÖ 0 new TypeScript errors
‚úÖ Manual testing confirmed on multiple viewport sizes
‚úÖ Code reviewed (Subagent + Semgrep + CodeRabbit = 0 Critical issues)

**Production Ready:** Yes, with comprehensive tests and REF MCP validation

---

## üìù Notes

### Key Insights

**1. Reuse > Recreate**
- VideoThumbnail component already handles xlarge sizing (Task #31)
- No need to create separate thumbnail component for Grid view
- REF MCP Improvement #1 validated this approach

**2. Responsive Grid is Simple with Tailwind**
- `grid-cols-2 md:grid-cols-3 lg:grid-cols-4` covers all screen sizes
- Standard breakpoints work well for most users
- No custom CSS needed

**3. PurgeCSS Safety is CRITICAL**
- ALL Tailwind classes must be complete strings in code
- Template literals break production builds
- See Task #31 for detailed explanation

**4. Automatic Layout Switch is Simpler UX**
- xlarge size implies Grid view (natural fit)
- One control instead of two (size + view mode)
- Can add manual toggle later if needed (non-breaking)

### Future Enhancements (Out of Scope)

**Not included in this task (can be added later):**

1. **View Mode Toggle** - Manual Table/Grid switch independent of size
2. **Grid Column Customization** - User chooses 2-6 columns
3. **Masonry Layout** - Pinterest-style variable height cards
4. **Infinite Scroll** - Load more videos as user scrolls
5. **Card Animations** - Fade-in, slide-in effects on render
6. **Bulk Selection** - Checkboxes for multi-select actions

---

**Created:** 2025-11-04
**Author:** Claude Code
**Status:** Ready for Implementation
**REF MCP Validated:** ‚úÖ Yes (5 patterns validated)
